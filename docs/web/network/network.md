# Ajax 请求头中常见content-type

1. ## application/x-www-form-urlencoded

   > 这应该是最常见的 POST 提交数据的方式了。浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。提交的数据按照 key1=val1&key2=val2 的方式进行编码

2. ## multipart/form-data

   > 这也是一个常见的 POST 数据提交的方式。我们使用表单上传文件时，就要让 form 的 enctype 等于这个值

3. ## application/json

   > 用来告诉服务端消息主体是序列化后的 JSON 字符串

4. ## text/xml

# 在浏览器输入地址

1. #### 缓存查找

   > 浏览器会先查看 **浏览器缓存** 中有没有这个地址， 如果没有那就再去 **系统缓存**， 如果系统缓存还没有， 那就去路由器缓存找， 总之只要缓存中有， 就说明有这个资源， 那浏览器直接显示出来就好了。

2. #### DNS 解析

   > 1. **先到各种缓存信息中查找**
   > 2. **DNS服务器查找**

3. #### 浏览器主机根据ip地址与服务器建立TCP连接

   > TCP 三次握手

4. #### 发送HTTP请求

5. #### 服务器处理请求

   > 服务器收到请求并响应，生成一个HTTP响应报文，通过TCP协议发送给浏览器主机

6. #### 断开TCP连接

7. #### 浏览器解析文件

   > 浏览器通过解析`HTML`，生成DOM树，解析`CSS`，生成CSS规则树，然后通过DOM树和CSS规则树生成渲染树。渲染树与DOM树不同，渲染树中并没有head、display为none等不必显示的节点。

# http 请求状态码

1. #### **2xx**（成功）

   ```javascript
   200     //成功  服务器已经成功处理了请求。通常，这表示服务器提供了请求的网页。
   201     //已创建  请求成功并且服务器创建了新的资源
   202     //已接受  服务器已接受请求，但尚未处理
   203     //非授权信息  服务器已经成功处理了请求，但返回的信息可能来自另一来源
   204     //无内容  服务器成功处理了请求，但没有返回任何内容
   205     //重置内容  服务器成功处理了请求，但没有返回任何内容
   206     //部分内容  服务器成功处理了部分GET请求
   ```

2. #### **3xx**（重定向）

   ```javascript
   301     //永久重定向，表示请求的资源已经永久的办到了其他位置
   302     //临时重定向，表示请求的资源临时搬到了其他位置
   303     //查看其它位置  请求者应当对不同的位置使用单独的GET请求来检索响应时，服务器返回此代码
   304     //未修改  自动上次请求后，请求的网页未修改过。服务器返回此响应，不会返回网页的内容
   305     //使用代理  请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理
   307     //临时性重定向  服务器目前从不同位置的网页响应请求，但请求者应继续使用原有的位置来进行以后的请求
   ```

3. #### 4xx（请求错误）

   ```javascript
   400     //客户端请求的语法错误，服务器无法理解
   401     //未授权  请求要求身份验证。对于需要登录的网页，服务器可能返回此响应
   403     //禁止  服务器拒绝请求
   404     //未找到  服务器找不到请求的网页
   ```

4. #### 5xx（服务器错误）

   ```javascript
   500     //服务器内部错误  服务器遇到错误，无法完成请求
   501     //尚未实施  服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码
   502     //错误网关  服务器作为网关或代理，从上游服务器无法收到无效响应
   503     //服务器不可用  服务器目前无法使用（由于超载或者停机维护）。通常，这只是暂时状态
   504     //网关超时  服务器作为网关代理，但是没有及时从上游服务器收到请求
   505     //HTTP版本不受支持  服务器不支持请求中所用的HTTP协议版本
   ```

### ajax 优缺点

> ajax的优点：可以实现局部刷新页面，即在页面不刷新的情况下获取数据。
>
> ajax的缺点：如果网速慢，则会出现ajax请求缓慢，页面空白的情况，对客户的体验不好。ajax请求不利于搜索引擎优化，一般搜不到ajax添加到页面的信息！
>
> 解决的办法：可以先用服务器渲染。

### 数据长度

HTTP协议从未规定过GET/POST请求长度是多少，所谓的请求长度限制由浏览器和Web服务器决定的，各种浏览器和 web 服务器的设定均不一样，这依赖于各个浏览器厂家的规定或者可以根据 web 服务器的处理能力来设定。传统IE中URL的最大可用长度为2048字符，其他浏览器对URL长度限制实现上有所不同，POST请求无长度限制（目前理论上是这样的）。

### [跨域解决方案](https://segmentfault.com/a/1190000011145364)

1. 通过jsonp跨域

   > jsonp缺点：只能实现get一种请求。

2. document.domain + iframe跨域

   > 此方案仅限主域相同，子域不同的跨域应用场景。
   >
   > 实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。

3. location.hash + iframe

   > 实现原理： a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。

4. window.name + iframe跨域

   > window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。

5. postMessage跨域

   > postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：
   > a.） 页面和其打开的新窗口的数据传递
   > b.） 多窗口之间消息传递
   > c.） 页面与嵌套的iframe消息传递
   > d.） 上面三个场景的跨域数据传递
   >
   > 用法：postMessage(data,origin)方法接受两个参数
   > data： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。
   > origin： 协议+主机+端口号，也可以设置为"*"，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为"/"。

6. 跨域资源共享（CORS）

7. nginx代理跨域

8. nodejs中间件代理跨域

9. WebSocket协议跨域

## cookie

### 属性

+ #### HTTPOnly

  设置 HTTPOnly 属性可以防止客户端脚本通过 document.cookie 等方式访问 Cookie，有助于避免 XSS 攻击。

+ #### SameSite

  SameSite 是最近非常值得一提的内容，因为 2 月份发布的 Chrome80 版本中默认屏蔽了第三方的 Cookie，这会导致阿里系的很多应用都产生问题，为此还专门成立了问题小组，推动各 BU 进行改造。

  ##### 作用

  我们先来看看这个属性的作用：

  SameSite 属性可以让 Cookie 在跨站请求时不会被发送，从而可以阻止跨站请求伪造攻击（CSRF）。

  ##### 属性值

  SameSite 可以有下面三种值：

  1. **Strict** 仅允许一方请求携带 Cookie，即浏览器将只发送相同站点请求的 Cookie，即当前网页 URL 与请求目标 URL 完全一致。
  2. **Lax** 允许部分第三方请求携带 Cookie
  3. **None** 无论是否跨站都会发送 Cookie

  之前默认是 None 的，Chrome80 后默认是 Lax。

  ##### 解决

  解决方案就是设置 SameSite 为 none。

### chrome 浏览器  samesite

https://blog.csdn.net/sinat_36521655/article/details/104844667?fps=1&locationNum=2