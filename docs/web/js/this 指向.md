# [this](https://mp.weixin.qq.com/s/YhV6A8dsU_sAyjfZTJevIQ)

### 1. 默认绑定

先介绍一种最简单的绑定方式吧：**默认绑定**。

也就是我们常说的：在非严格模式下`this`指向的是全局对象`window`，而在严格模式下会绑定到`undefined`。

### 2. 隐式绑定

谁最后调用的函数，函数内的`this`指向的就是谁(不考虑箭头函数)

### 3. 隐式绑定的隐式丢失问题

有两种情况容易发生隐式丢失问题：

- 使用另一个变量来给函数取别

  > this 指向它的最后调用者

- 将函数作为参数传递时会被隐式赋值，回调函数丢失this绑定

  > 如果你把一个函数当成参数传递到另一个函数的时候，也会发生隐式丢失的问题，且与包裹着它的函数的this指向无关。在非严格模式下，会把该函数的this绑定到window上，严格模式下绑定到undefined

### 4. 显式绑定

通过`call()、apply()`或者`bind()`方法直接指定`this`的绑定对象, 如`foo.call(obj)`。

这里有几个知识点需要注意：

- 使用`.call()`或者`.apply()`的函数是会直接执行的
- `bind()`是创建一个新的函数，需要手动调用才会执行
- `.call()`和`.apply()`用法基本类似，不过`call`接收若干个参数，而`apply`接收的是一个数组

### 总结

+ `this` 永远指向最后调用它的那个对象
+ 匿名函数的`this`永远指向`window`
+ 使用`.call()`或者`.apply()`的函数是会直接执行的
+ `bind()`是创建一个新的函数，需要手动调用才会执行
+ 如果`call、apply、bind`接收到的第一个参数是空或者`null、undefined`的话，则会忽略这个参数
+ `forEach、map、filter`函数的第二个参数也是能显式绑定`this`的



### 6. new 绑定

使用`new`来调用一个函数，会构造一个新对象并把这个新对象绑定到调用函数中的`this`。



### 7. 箭头函数绑定

箭头函数中没有 this 绑定，必须通过查找作用域链来决定其值，如果箭头函数被非箭头函数包含，则 this 绑定的是最近一层非箭头函数的 this，否则，this 为 undefined。且指向函数定义时的this而非执行时

### 总结 箭头函数的指向

- 它里面的`this`是由外层作用域来决定的，且指向函数定义时的`this`而非执行时
- 字面量创建的对象，作用域是`window`，如果里面有箭头函数属性的话，`this`指向的是`window`
- 构造函数创建的对象，作用域是可以理解为是这个构造函数，且这个构造函数的`this`是指向新建的对象的，因此`this`指向这个对象。
- 箭头函数的`this`是无法通过`bind、call、apply`来**直接**修改，但是可以通过改变作用域中`this`的指向来间接修改。



