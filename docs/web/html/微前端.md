## single-spa

## [Qiankun](https://qiankun.umijs.org/zh)

实现原理https://blog.csdn.net/qq_41694291/article/details/113842872

微前端架构具备以下几个核心价值：

- 技术栈无关
  主框架不限制接入应用的技术栈，微应用具备完全自主权

- 独立开发、独立部署
  微应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新

- 增量升级

  在面对各种复杂场景时，我们通常很难对一个已经存在的系统做全量的技术栈升级或重构，而微前端是一种非常好的实施渐进式重构的手段和策略

- 独立运行时
  每个微应用之间状态隔离，运行时状态不共享

### 基于 shadow DOM 的样式隔离

样式隔离也是微前端面临的一个重要问题，在 qiankun@1.x 中，我们支持了微应用之间的样式隔离（仅沙箱开启时生效），这尚存一些问题：

1. 主子应用之间的样式隔离依赖手动配置插件处理
2. 多应用场景下微应用之间的样式隔离亟待处理

为此，我们引入了一个新的选项， `sandbox: { strictStyleIsolation?: boolean }` 。

在该选项开启的情况下，我们会以 Shadow DOM 的形式嵌入微应用，以此来做到应用样式的真正隔离：

```ts
import { loadMicroApp } from 'qiankun'

loadMicroApp({xxx}, { sandbox: { strictStyleIsolation: true } });
```

### 目前微前端解决方案

1. iframe：是传统的微前端解决方案，基于iframe标签实现，技术难度低，隔离性和兼容性很好，但是性能和使用体验比较差，多用于集成第三方系统；
2. 基座模式：主要基于路由分发，即由一个基座应用来监听路由，并按照路由规则来加载不同的应用，以实现应用间解耦；（single-spa,qiankun）
3. 组合式集成：把组件单独打包和发布，然后在构建或运行时组合；
4. EMP：基于Webpack5 Module Federation，一种去中心化的微前端实现方案，它不仅能很好地隔离应用，还可以轻松实现应用间的资源共享和通信；
5. Web Components：是官方提出的组件化方案，它通过对组件进行更高程度的封装，来实现微前端，但是目前兼容性不够好，尚未普及。

总的来说，iframe主要用于简单并且性能要求不高的第三方系统；组合式集成目前主要用于前端组件化，而不是微前端；基座模式、EMP和Web Components是目前主流的微前端方案。

### qiankun实现原理

qiankun主要采用HTML Entry模式，直接将子应用打出来 HTML作为入口，主框架可以通过 fetch html 的方式获取子应用的静态资源，同时将 HTML document 作为子节点塞到主框架的容器中。这样不仅可以极大的减少主应用的接入成本，子应用的开发方式及打包方式基本上也不需要调整，而且可以天然的解决子应用之间样式隔离的问题。

一般来说，微前端需要解决的问题分为两大类：

1. **应用的加载与切换**
2. **应用的隔离与通信**

应用的加载与切换需要解决的问题包括：**路由问题、应用入口、应用加载**；应用的隔离与通信需要解决的问题包括：**js隔离、css样式隔离、应用间通信**。

1. **应用加载**

   `qiankun`使用`import-html-entry`加载应用入口

single-spa很好地解决了路由和应用入口两个问题，但并没有解决应用加载问题，而是将该问题暴露出来由使用者实现（一般可以用system.js或原生script标签来实现）；qiankun在此基础上封装了一个应用加载方案（即import-html-entry），并给出了js隔离、css样式隔离和应用间通信三个问题的解决方案，同时提供了预加载功能。

从目前微前端的发展来看，webpack5的Module Federation可能会成为一个焦点功能，用于解决微前端应用间的资源共享问题（EMP已经做到了这一点，qiankun的维护者也表示会集成这一功能）。当然了，随着Web Components功能的不断增强，也许浏览器本身就是微前端最完美的运行时容器。除了运行时容器，本文开篇提到的版本管理、质量管控、配置下发、线上监控、灰度发布、安全监测等，也必将成为微前端领域接下来要重点解决的问题。

