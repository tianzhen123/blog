<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>korn的博客</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="专注 前端 技术栈分享，从前端到Node.js再到数据库">
    
    <link rel="preload" href="/blog/assets/css/0.styles.a4691601.css" as="style"><link rel="preload" href="/blog/assets/js/app.016ecbb7.js" as="script"><link rel="preload" href="/blog/assets/js/2.928a6fe7.js" as="script"><link rel="preload" href="/blog/assets/js/18.05c8eb0b.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.77b39606.js"><link rel="prefetch" href="/blog/assets/js/11.62e42ab5.js"><link rel="prefetch" href="/blog/assets/js/12.f45a62f5.js"><link rel="prefetch" href="/blog/assets/js/13.2602d9e7.js"><link rel="prefetch" href="/blog/assets/js/14.72eeec06.js"><link rel="prefetch" href="/blog/assets/js/15.933c999c.js"><link rel="prefetch" href="/blog/assets/js/16.fa841be8.js"><link rel="prefetch" href="/blog/assets/js/17.16734f12.js"><link rel="prefetch" href="/blog/assets/js/19.42269bb6.js"><link rel="prefetch" href="/blog/assets/js/20.3bb5a14c.js"><link rel="prefetch" href="/blog/assets/js/21.f33e7cfe.js"><link rel="prefetch" href="/blog/assets/js/22.b073c1aa.js"><link rel="prefetch" href="/blog/assets/js/23.971df460.js"><link rel="prefetch" href="/blog/assets/js/24.7fc7e003.js"><link rel="prefetch" href="/blog/assets/js/25.4c8c73e4.js"><link rel="prefetch" href="/blog/assets/js/26.6b941ac2.js"><link rel="prefetch" href="/blog/assets/js/27.38b0556e.js"><link rel="prefetch" href="/blog/assets/js/28.c824e37c.js"><link rel="prefetch" href="/blog/assets/js/29.44a1851e.js"><link rel="prefetch" href="/blog/assets/js/3.6ab95d19.js"><link rel="prefetch" href="/blog/assets/js/30.50b73b19.js"><link rel="prefetch" href="/blog/assets/js/4.ba3164ba.js"><link rel="prefetch" href="/blog/assets/js/5.75a3592b.js"><link rel="prefetch" href="/blog/assets/js/6.0377ba0c.js"><link rel="prefetch" href="/blog/assets/js/7.888c74f3.js"><link rel="prefetch" href="/blog/assets/js/8.c67934ea.js"><link rel="prefetch" href="/blog/assets/js/9.d9926b68.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.a4691601.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">korn的博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><span class="title">前端</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端" class="mobile-dropdown-title"><span class="title">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/web/Interview/learn.html" class="nav-link">
  面试题
</a></li><li class="dropdown-item"><!----> <a href="/blog/web/css/css.html" class="nav-link">
  css
</a></li><li class="dropdown-item"><!----> <a href="/blog/web/js/js.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  js
</a></li><li class="dropdown-item"><!----> <a href="/blog/web/vue/vue.html" class="nav-link">
  vue
</a></li><li class="dropdown-item"><!----> <a href="/blog/web/network/network.html" class="nav-link">
  network
</a></li><li class="dropdown-item"><!----> <a href="/blog/web/webpack/learn.html" class="nav-link">
  webpack
</a></li></ul></div></div><div class="nav-item"><a href="/blog/node/learn.html" class="nav-link">
  node
</a></div><div class="nav-item"><a href="/blog/dataBase/mysql/learn.html" class="nav-link">
  数据库
</a></div><div class="nav-item"><a href="/blog/git/learn.html" class="nav-link">
  git
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><span class="title">前端</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端" class="mobile-dropdown-title"><span class="title">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/web/Interview/learn.html" class="nav-link">
  面试题
</a></li><li class="dropdown-item"><!----> <a href="/blog/web/css/css.html" class="nav-link">
  css
</a></li><li class="dropdown-item"><!----> <a href="/blog/web/js/js.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  js
</a></li><li class="dropdown-item"><!----> <a href="/blog/web/vue/vue.html" class="nav-link">
  vue
</a></li><li class="dropdown-item"><!----> <a href="/blog/web/network/network.html" class="nav-link">
  network
</a></li><li class="dropdown-item"><!----> <a href="/blog/web/webpack/learn.html" class="nav-link">
  webpack
</a></li></ul></div></div><div class="nav-item"><a href="/blog/node/learn.html" class="nav-link">
  node
</a></div><div class="nav-item"><a href="/blog/dataBase/mysql/learn.html" class="nav-link">
  数据库
</a></div><div class="nav-item"><a href="/blog/git/learn.html" class="nav-link">
  git
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Interview</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>css</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>js</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/web/js/js.html" aria-current="page" class="active sidebar-link">js常考面试题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/web/js/js.html#js-数据类型" class="sidebar-link">js 数据类型</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/js.html#从输入url到浏览器显示页面发生了什么" class="sidebar-link">从输入URL到浏览器显示页面发生了什么</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/js.html#es6-新特性" class="sidebar-link">es6 新特性</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/js.html#promise" class="sidebar-link">promise</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/js.html#foreach-如何跳出循环" class="sidebar-link">foreach 如何跳出循环</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/js.html#foreach-map-会不会改变原数组" class="sidebar-link">foreach,map 会不会改变原数组</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/js.html#ie-适配" class="sidebar-link">ie 适配</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/js.html#防抖和节流" class="sidebar-link">防抖和节流</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/js.html#几种判断数据类型的优缺点" class="sidebar-link">几种判断数据类型的优缺点</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/js.html#export-和-export-default-的区别-es6" class="sidebar-link">export 和 export default 的区别(es6)</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/js.html#阻止冒泡事件和默认事件" class="sidebar-link">阻止冒泡事件和默认事件</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/js.html#作用域-分为-全局作用域-和-函数作用域" class="sidebar-link">作用域：分为 全局作用域 和 函数作用域</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/js.html#call、bind、apply-区别" class="sidebar-link">call、bind、apply 区别</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/js.html#事件循环-event-loop" class="sidebar-link">事件循环(Event Loop)</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/js.html#面向对象" class="sidebar-link">面向对象</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/js.html#继承-es5" class="sidebar-link">继承（es5）</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/js.html#闭包" class="sidebar-link">闭包</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/js.html#递归函数" class="sidebar-link">递归函数</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/js.html#拷贝" class="sidebar-link">拷贝</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/js.html#let-和-const-var" class="sidebar-link">let 和 const,var</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/js.html#箭头函数中的-this" class="sidebar-link">箭头函数中的 this</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/js.html#commonjs与es6-modules规范的区别" class="sidebar-link">CommonJS与ES6 Modules规范的区别</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/js.html#foreach" class="sidebar-link">foreach</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/js.html#script标签的额-async-和-defer" class="sidebar-link">script标签的额 async 和 defer</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/js.html#cordova" class="sidebar-link">cordova</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/js.html#js-sdk-通讯方式" class="sidebar-link">js sdk 通讯方式</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/js.html#纯函数" class="sidebar-link">纯函数</a></li><li class="sidebar-sub-header"><a href="/blog/web/js/js.html#前端轮子-https-www-zhihu-com-question-29380608" class="sidebar-link">前端轮子：https://www.zhihu.com/question/29380608</a></li></ul></li><li><a href="/blog/web/js/errorReport.html" class="sidebar-link">错误上报</a></li><li><a href="/blog/web/js/this 指向.html" class="sidebar-link">this 指向</a></li><li><a href="/blog/web/js/typescript.html" class="sidebar-link">typescript</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>html</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>vue</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>network</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>webpack</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p>[TOC]</p> <h2 id="js-数据类型"><a href="#js-数据类型" class="header-anchor">#</a> js 数据类型</h2> <ul><li>基本类型 string、number、boolean、null、undefined、symbol</li> <li>引用类型 Object、Array、RegExp、Date、Function</li> <li>类型判断 <code>Object.prototype.toString.call()</code></li></ul> <h2 id="从输入url到浏览器显示页面发生了什么"><a href="#从输入url到浏览器显示页面发生了什么" class="header-anchor">#</a> <a href="https://mp.weixin.qq.com/s/DLq_GIkdnuOayThfi3jI0A" target="_blank" rel="noopener noreferrer">从输入URL到浏览器显示页面发生了什么<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></h2> <ol><li>首先，在浏览器地址中输入url</li> <li>浏览器先查看<strong>浏览器缓存</strong>-系统缓存-路由器缓存，如果缓存中有，会直接在屏幕中显示页面内容。若没有，则跳到第三步操作</li> <li>浏览器向DNS（Domain Name System）服务器请求解析该URL中的域名对应的IP地址</li> <li>解析出IP地址后，根据该IP地址和默认端口80，和服务器建立TCP连接</li> <li>浏览器发送HTTP请求，该请求报文作为TCP三次握手的第三个报文的数据发送给服务器</li> <li>服务器对浏览器请求做出响应，并把对应的html文本发送给浏览器</li> <li>释放TCP连接</li> <li>浏览器将该html文本并显示内容</li></ol> <h2 id="es6-新特性"><a href="#es6-新特性" class="header-anchor">#</a> es6 新特性</h2> <p>let ，展开运算符，箭头函数，数组的解构赋值、对象的解构赋值</p> <h2 id="promise"><a href="#promise" class="header-anchor">#</a> promise</h2> <p>三种状态：</p> <ul><li>pending，异步任务正在进行。</li> <li>resolved (也可以叫fulfilled)，异步任务执行成功。</li> <li>rejected，异步任务执行失败。</li></ul> <p>API：</p> <ul><li>Promise.resolve(value)</li> <li>Promise.reject</li> <li>Promise.prototype.then</li> <li>Promise.prototype.catch</li> <li>Promise.race</li> <li>Promise.all</li></ul> <h2 id="foreach-如何跳出循环"><a href="#foreach-如何跳出循环" class="header-anchor">#</a> foreach 如何跳出循环</h2> <p>因为forEach()无法通过正常流程终止，所以可以通过抛出异常的方式实现终止</p> <h2 id="foreach-map-会不会改变原数组"><a href="#foreach-map-会不会改变原数组" class="header-anchor">#</a> foreach,map 会不会改变原数组</h2> <p>其实 forEach 和 map 的最大共同点就是都是函数, item 就相当于是形参, 我原来一直认为形参不会改变实参, 但其实并不是这样的, 类比上面结论可以得知:</p> <p>如果实参是基本类型, 那确实改变不了实参;</p> <p>如果实参是引用类型:</p> <p>函数修改了形参的地址值或将其修改为基本类型, 改变不了实参</p> <p>函数没有修改形参的地址值, 只是修改形参内部的某些属性, 会改变实参</p> <h2 id="ie-适配"><a href="#ie-适配" class="header-anchor">#</a> ie 适配</h2> <ul><li><p>babel-polyfill <strong>在index.html 加入以下代码（非必须）</strong></p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token operator">&lt;</span>meta http<span class="token operator">-</span>equiv<span class="token operator">=</span><span class="token string">&quot;X-UA-Compatible&quot;</span> content<span class="token operator">=</span><span class="token string">&quot;IE=edge,chrome=1&quot;</span><span class="token operator">&gt;</span>
</code></pre></div></li></ul> <h2 id="防抖和节流"><a href="#防抖和节流" class="header-anchor">#</a> 防抖和节流</h2> <ul><li><p>节流是一定时间内，回调函数只执行一次。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span>delay</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">let</span> valid <span class="token operator">=</span> <span class="token boolean">true</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>valid<span class="token punctuation">)</span><span class="token punctuation">{</span>
           <span class="token comment">//休息时间</span>
           <span class="token keyword">return</span> <span class="token boolean">false</span> 
       <span class="token punctuation">}</span>
       <span class="token comment">// 工作时间，执行函数并且在间隔期内把状态位设为无效</span>
        valid <span class="token operator">=</span> <span class="token boolean">false</span>
        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            valid <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> delay<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>防抖是一定时间内，回调函数只执行一次，但期间若有事件触发，则重新计时。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span>delay</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">let</span> timer <span class="token operator">=</span> <span class="token keyword">null</span> <span class="token comment">//借助闭包</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span> 
        <span class="token punctuation">}</span>
        timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span>delay<span class="token punctuation">)</span> <span class="token comment">// 简化写法</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <p>​	如果遇到的是连续不停的事件，则应该选择节流，因为不停触发的事件会让防抖只会执行一次回调函数</p> <h2 id="几种判断数据类型的优缺点"><a href="#几种判断数据类型的优缺点" class="header-anchor">#</a> 几种判断数据类型的优缺点</h2> <ol><li><p>typeof</p> <ul><li><p>优点：能够快速区分基本数据类型</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span> <span class="token comment">// number</span>
</code></pre></div></li> <li><p>缺点：不能将Object、Array和Null区分，都返回object</p></li></ul></li> <li><p>instanceof</p> <ul><li>优点：能够区分Array、Object和Function，适合用于判断自定义的类实例对象 ([] instanceof Array)</li> <li>缺点：Number，Boolean，String基本数据类型不能判断</li></ul></li> <li><p>Object.prototype.toString.call()</p> <ul><li>优点：精准判断数据类型</li> <li>缺点：写法繁琐不容易记，推荐进行封装后使用</li></ul></li></ol> <h2 id="export-和-export-default-的区别-es6"><a href="#export-和-export-default-的区别-es6" class="header-anchor">#</a> export 和 export default 的区别(es6)</h2> <ol><li>export default 在一个模块里只能有一个，但是export可以有多个</li> <li>export default 向外暴露的成员，可以用任意的变量来接收</li> <li>export 向外暴露的成员，需要用{}来接收（按需导出），可以用 as 的方式来起别名，可以同时导出多个</li></ol> <h2 id="阻止冒泡事件和默认事件"><a href="#阻止冒泡事件和默认事件" class="header-anchor">#</a> 阻止冒泡事件和默认事件</h2> <ul><li><p>当需要停止冒泡行为时，可以使用</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">stopBubble</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
<span class="token comment">//如果提供了事件对象，则这是一个非IE浏览器 </span>
<span class="token keyword">if</span> <span class="token punctuation">(</span> e <span class="token operator">&amp;&amp;</span> e<span class="token punctuation">.</span>stopPropagation <span class="token punctuation">)</span> 
    <span class="token comment">//因此它支持W3C的stopPropagation()方法 </span>
    e<span class="token punctuation">.</span><span class="token function">stopPropagation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token keyword">else</span>
    <span class="token comment">//否则，我们需要使用IE的方式来取消事件冒泡 </span>
    window<span class="token punctuation">.</span>event<span class="token punctuation">.</span>cancelBubble <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>当需要阻止默认行为时，可以使用</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">//阻止浏览器的默认行为 </span>
<span class="token keyword">function</span> <span class="token function">stopDefault</span><span class="token punctuation">(</span> <span class="token parameter">e</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token comment">//阻止默认浏览器动作(W3C) </span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span> e <span class="token operator">&amp;&amp;</span> e<span class="token punctuation">.</span>preventDefault <span class="token punctuation">)</span> 
        e<span class="token punctuation">.</span><span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token keyword">else</span>
      <span class="token comment">//IE中阻止函数器默认动作的方式 </span>
        window<span class="token punctuation">.</span>event<span class="token punctuation">.</span>returnValue <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> 
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h2 id="作用域-分为-全局作用域-和-函数作用域"><a href="#作用域-分为-全局作用域-和-函数作用域" class="header-anchor">#</a> 作用域：分为 <strong>全局作用域</strong> 和 <strong>函数作用域</strong></h2> <ol><li>全局作用域：代码在程序的任何地方都能被访问，window 对象的内置属性都拥有全局作用域。</li> <li>函数作用域：在固定的代码片段才能被访问</li> <li>作用域链：<strong>一般情况下，变量取值到 创建 这个变量 的函数的作用域中取值。</strong> <strong>但是如果在当前作用域中没有查到值，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链。</strong></li></ol> <h2 id="call、bind、apply-区别"><a href="#call、bind、apply-区别" class="header-anchor">#</a> call、bind、apply 区别</h2> <ul><li>bind与apply、call最大的区别就是：bind不会立即调用，其他两个会立即调用</li> <li>apply与call的区别是apply第二个是参数组，但是在确定的参数下，还是最好用call，call的效果会更高，但是在函数的延展性上使用apply更好</li></ul> <table><thead><tr><th>宏任务（Macrotask）</th> <th>微任务（Microtask）</th></tr></thead> <tbody><tr><td>setTimeout</td> <td>requestAnimationFrame（有争议）</td></tr> <tr><td>setInterval</td> <td>MutationObserver（浏览器环境）</td></tr> <tr><td>MessageChannel</td> <td>Promise.[ then/catch/finally ]</td></tr> <tr><td>I/O，事件队列</td> <td>process.nextTick（Node环境）</td></tr> <tr><td>setImmediate（Node环境）</td> <td>queueMicrotask</td></tr> <tr><td>script（整体代码块）</td> <td></td></tr></tbody></table> <h2 id="事件循环-event-loop"><a href="#事件循环-event-loop" class="header-anchor">#</a> 事件循环(Event Loop)</h2> <p>首先，整体的script(作为第一个宏任务)开始执行的时候，会把所有代码分为<code>同步任务</code>、<code>异步任务</code>两部分</p> <p>同步任务会直接进入主线程依次执行</p> <p>异步任务会再分为宏任务和微任务</p> <p>宏任务进入到Event Table中，并在里面注册回调函数，每当指定的事件完成时，Event Table会将这个函数移到Event Queue中</p> <p>微任务也会进入到另一个Event Table中，并在里面注册回调函数，每当指定的事件完成时，Event Table会将这个函数移到Event Queue中</p> <p>当主线程内的任务执行完毕，主线程为空时，会检查微任务的Event Queue，如果有任务，就全部执行，如果没有就执行下一个宏任务</p> <p>上述过程会不断重复，这就是Event Loop，比较完整的事件循环</p> <h2 id="面向对象"><a href="#面向对象" class="header-anchor">#</a> 面向对象</h2> <h3 id="类的本质"><a href="#类的本质" class="header-anchor">#</a> 类的本质</h3> <ul><li>类的本质其实是 function（函数）</li> <li>类其实是构造函数的另外一种写法</li></ul> <h3 id="类的继承-es6"><a href="#类的继承-es6" class="header-anchor">#</a> 类的继承（es6）</h3> <ul><li><p>super关键字</p> <p>子类在构造函数中使用 super，必须放到this 前面</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">pName</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>pName <span class="token operator">=</span> pName
    <span class="token punctuation">}</span>
    <span class="token function">sayP</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>pName<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Student</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">sName</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>sName<span class="token punctuation">)</span> <span class="token comment">// 必须放在 this 赋值的前面</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>sName <span class="token operator">=</span> sName
    <span class="token punctuation">}</span>
    <span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>sName<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> stu <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Student</span><span class="token punctuation">(</span><span class="token string">'小明'</span><span class="token punctuation">)</span>
stu<span class="token punctuation">.</span><span class="token function">sayP</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div></li></ul> <h3 id="类的使用注意事项"><a href="#类的使用注意事项" class="header-anchor">#</a> 类的使用注意事项</h3> <ul><li>类没有变量提升，所以需要先定义类，再实例化对象</li> <li>类里面共有的属性和方法，必须加 this使用</li> <li>类里面 this 的只想问题</li></ul> <h2 id="继承-es5"><a href="#继承-es5" class="header-anchor">#</a> 继承（es5）</h2> <ol><li><p>原型链集成</p></li> <li><p>借用构造函数继承</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&quot;red&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;blue&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;green&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">//继承SuperType</span>
	<span class="token function">SuperType</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> instance1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
instance1<span class="token punctuation">.</span>colors<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">&quot;black&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>instance1<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;red,blue,green,black&quot;</span>
<span class="token keyword">var</span> instance2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>instance2<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;red,blue,green&quot; </span>
</code></pre></div><blockquote><p>存在的问题就是，所有的类型都只能使用构造函数模式（因为超类型的原型中定义的方法对于子类型不可见），因此方法都在构造函数中定义，函数复用就无从谈起了</p></blockquote></li> <li><p>组合继承</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">SuperType</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>colors <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&quot;red&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;blue&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;green&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">SuperType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">SubType</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> age</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// 继承属性</span>
	<span class="token function">SuperType</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 继承方法</span>
<span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SuperType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> SubType<span class="token punctuation">;</span>
<span class="token class-name">SubType</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sayAge</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token function">alert</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> instance1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token string">&quot;Nicholas&quot;</span><span class="token punctuation">,</span> <span class="token number">29</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
instance1<span class="token punctuation">.</span>colors<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">&quot;black&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>instance1<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;red,blue,green,black&quot;</span>
instance1<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;Nicholas&quot;;</span>
instance1<span class="token punctuation">.</span><span class="token function">sayAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//29</span>
<span class="token keyword">var</span> instance2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SubType</span><span class="token punctuation">(</span><span class="token string">&quot;Greg&quot;</span><span class="token punctuation">,</span> <span class="token number">27</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">alert</span><span class="token punctuation">(</span>instance2<span class="token punctuation">.</span>colors<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;red,blue,green&quot;</span>
instance2<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//&quot;Greg&quot;;</span>
instance2<span class="token punctuation">.</span><span class="token function">sayAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//27 </span>
</code></pre></div><blockquote><p>因为在子类型中借调构造函数(SuperType.call(this))时，会在自己的所有实例中执行一遍SuperType中的代码，由于每个实例this都是不同的，因此SuperType中定义的属性会在每个实例中有一份副本，也就避免了原型链继承中，原型属性共享的问题（覆盖了原型属性）。</p></blockquote></li></ol> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Father</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&quot;xiaoming&quot;</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">Father</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">say</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">Son</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">Father</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token class-name">Son</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token class-name">Father</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Son</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Son<span class="token punctuation">;</span>

<span class="token keyword">var</span> per <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Son</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
per<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">12</span>
per<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> per2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Son</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
per2<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="插入元素"><a href="#插入元素" class="header-anchor">#</a> 插入元素</h3> <ul><li>insertAdjackentHTML() 支持追加字符串元素</li> <li>appentChild 不支持追加字符串元素，只能先createElement</li></ul> <h3 id="构造函数-new-原理"><a href="#构造函数-new-原理" class="header-anchor">#</a> 构造函数（new 原理）</h3> <ul><li><p>在 new 的时候会执行的四件事</p> <ol><li><p>在内存中创建一个新的空对象</p></li> <li><p>让 this 指向这个新对象</p></li> <li><p>执行构造函数，给新对象添加属性和方法</p></li> <li><p>返回这个新对象（构造函数中不要return）</p></li></ol></li> <li><p>构造函数的成员分为<strong>实例成员</strong>和<strong>静态成员</strong></p> <ol><li><p>实例成员：就是构造函数里面通过 this 添加的成员</p></li> <li><p>静态成员：在构造函数身上添加的成员（静态函数只能通过构造函数来访问）</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// es5 通过构造函数来实现类和对象</span>
<span class="token keyword">function</span> <span class="token function">Star</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name <span class="token comment">// 实例成员</span>
  <span class="token comment">//	this.sing = function(){</span>
   <span class="token comment">//   console.log('唱歌')</span>
  <span class="token comment">//  }</span>
<span class="token punctuation">}</span>
<span class="token class-name">Star</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">sing</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">// 在原型上添加对象</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'唱歌'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> ldh <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Star</span><span class="token punctuation">(</span><span class="token string">'刘德华'</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>ldh<span class="token punctuation">.</span>name<span class="token punctuation">)</span> <span class="token comment">// 实例成员通过对象访问</span>
Star<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">20</span> <span class="token comment">// 静态成员</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Star<span class="token punctuation">.</span>age<span class="token punctuation">)</span> <span class="token comment">// 静态成员通过构造函数访问</span>
</code></pre></div></li></ol></li> <li><p>构造函数的原型 prototype</p> <ul><li>原型：原型是一个对象，也称prototype为原型对象</li> <li>原型的作用：共享方法</li></ul></li> <li><p><code>__proto__</code>是对象自动添加的一个对象，它指向构造函数的原型对象 prototype</p> <img src="https://raw.githubusercontent.com/tianzhen123/blog/master/docs/assets/3.png" alt="image-20200226154459348" style="zoom:50%;"></li> <li><p>构造函数的 constructor</p> <ul><li><p>constructor主要用来记录到底引用的哪个构造函数，它可以让原型对象重新指向原来的构造函数</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>ldh<span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span>contructor <span class="token operator">===</span> <span class="token class-name">Star</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token comment">// true</span>
</code></pre></div></li> <li><p>构造函数、实例、原型对象之间的关系</p> <img src="https://raw.githubusercontent.com/tianzhen123/blog/master/docs/assets/1.png" alt="关系" style="zoom:50%;"></li> <li><p>原型链</p> <p><img src="https://raw.githubusercontent.com/tianzhen123/blog/master/docs/assets/2.png" alt="原型链"></p></li></ul></li></ul> <h3 id="object-defineproperty-定义对象中新的属性或修改属性"><a href="#object-defineproperty-定义对象中新的属性或修改属性" class="header-anchor">#</a> Object.defineProperty() 定义对象中新的属性或修改属性</h3> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">// obj:要修改的对象</span>
<span class="token comment">// key:添加或修改的属性</span>
<span class="token comment">// newValue:新的值</span>
<span class="token comment">// writable:是否允许重写</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span>key<span class="token punctuation">,</span><span class="token punctuation">{</span>
  value<span class="token operator">:</span>newValue，
  writable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token operator">/</span><span class="token boolean">false</span><span class="token punctuation">,</span>
  enumerable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">// 当且仅当该属性的enumerable为true时，该属性才能够出现在对象的枚举属性中。默认为 false</span>
  configurable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">// 当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false。</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span> 
</code></pre></div><h3 id="object-keys-获取对象的所有属性名-返回值是数组"><a href="#object-keys-获取对象的所有属性名-返回值是数组" class="header-anchor">#</a> Object.keys() 获取对象的所有属性名，返回值是数组</h3> <h3 id="改变-this-指向的方法"><a href="#改变-this-指向的方法" class="header-anchor">#</a> 改变 this 指向的方法</h3> <p>thisArg 是 this 指向</p> <ul><li>call：fun.call( thisArg, arg1, arg2 )</li> <li>apply：fun.apply( thisArg, [argsArray] )</li> <li>bind：fun.bind(thisArg, arg1, arg2) // bind 不会调用函数，返回值是修改后的新函数</li></ul> <h3 id="严格模式-use-strict"><a href="#严格模式-use-strict" class="header-anchor">#</a> 严格模式<code>'use strict'</code></h3> <div class="language-javascript extra-class"><pre class="language-javascript"><code> <span class="token comment">// https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode</span>
</code></pre></div><p>注意：严格模式只在 ie10以上的版本才会支持，旧版本会忽略</p> <ul><li><p><strong>变量：</strong></p> <ul><li>不能使用未定义的变量</li> <li>不能删除已经定义的变量（ delete num；）</li></ul></li> <li><p><strong>this 指向问题</strong></p> <ul><li>严格模式下全局作用域中函数中的 this 是 undefined</li> <li>如果构造函数不用 new 来调用，this会报错</li> <li>定时器里的 this 指向的还是 window</li></ul></li> <li><p>函数中不能有重名的参数</p></li></ul> <h2 id="闭包"><a href="#闭包" class="header-anchor">#</a> 闭包</h2> <ul><li><p>父函数将子函数作为返回值，再将子函数赋值给一个变量，所以子函数会存在于内存中，而子函数依赖于父函数存在，所以父函数也会存在于内存中，也就不会被垃圾回收机制回收。</p></li> <li><p>定义：**闭包 ** 是指有权访问另一个函数作用域中的变量的函数</p></li> <li><p>作用：延伸了变量的作用范围</p></li> <li><p>使用：防抖和节流；把变量隐藏起来，不让外面拿到和修改</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">i</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
         <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div></li></ul> <h2 id="递归函数"><a href="#递归函数" class="header-anchor">#</a> 递归函数</h2> <ul><li><p>用递归计算 n 的阶乘</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">con</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> n <span class="token operator">*</span> <span class="token function">con</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">con</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li></ul> <h2 id="拷贝"><a href="#拷贝" class="header-anchor">#</a> 拷贝</h2> <ul><li><p>浅拷贝</p> <ul><li>es6 浅拷贝方法：Object.assign(target,...sources)</li></ul></li> <li><p>深拷贝</p> <ol><li>用for…in实现遍历和复制</li></ol> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">deepClone</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> target <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> key <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'object'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">deepClone</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> target<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ol start="2"><li>JSON 的方式实现</li></ol> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">deepClone2</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> _obj <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token keyword">var</span> objClone <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>_obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> objClone<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ol start="3"><li>利用数组的Array.prototype.forEach进copy</li></ol></li></ul> <h2 id="let-和-const-var"><a href="#let-和-const-var" class="header-anchor">#</a> let 和 const,var</h2> <ul><li>let 声明的变量具有块级作用域，切可以改变</li> <li>let 没有变量提升，let 不可以重复定义，let 是块级作用域</li> <li>const 声明的变量具有块级作用域，常量声明后不能更改值，引用数据类型声明可以改变。（声明时必须赋值）</li></ul> <h2 id="箭头函数中的-this"><a href="#箭头函数中的-this" class="header-anchor">#</a> 箭头函数中的 this</h2> <ul><li><p>箭头函数不绑定 this，箭头函数中的 this 指向函数定义位置的上下文this</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> obj<span class="token operator">=</span><span class="token punctuation">{</span>
  a<span class="token operator">:</span><span class="token number">5</span><span class="token punctuation">,</span>
  <span class="token function-variable function">say</span><span class="token operator">:</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
obj<span class="token punctuation">.</span><span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 100 因为 obj 是个对象，不能产生作用域，所以 say 中的 this 指向 window</span>
<span class="token comment">// 作用域分为全局作用域和函数作用域</span>
</code></pre></div></li></ul> <h2 id="commonjs与es6-modules规范的区别"><a href="#commonjs与es6-modules规范的区别" class="header-anchor">#</a> CommonJS与ES6 Modules规范的区别</h2> <ul><li>CommonJS模块是运行时加载，ES6 Modules是编译时输出接口</li> <li>CommonJS输出是值的拷贝；ES6 Modules输出的是值的引用，被输出模块的内部的改变会影响引用的改变</li> <li>CommonJs导入的模块路径可以是一个表达式，因为它使用的是<code>require()</code>方法；而ES6 Modules只能是字符串</li> <li>CommonJS <code>this</code>指向当前模块，ES6 Modules <code>this</code>指向<code>undefined</code></li> <li>且ES6 Modules中没有这些顶层变量：<code>arguments</code>、<code>require</code>、<code>module</code>、<code>exports</code>、<code>__filename</code>、<code>__dirname</code></li></ul> <h2 id="foreach"><a href="#foreach" class="header-anchor">#</a> foreach</h2> <ul><li><p><strong>当数组中元素是值类型，forEach绝对不会改变数组；当是引用类型，则可以改变数组</strong></p></li> <li><p>不支持链式操作</p></li></ul> <h2 id="script标签的额-async-和-defer"><a href="#script标签的额-async-和-defer" class="header-anchor">#</a> script标签的额 async 和 defer</h2> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">&quot;xxx&quot;</span>  async <span class="token operator">/</span><span class="token operator">&gt;</span> <span class="token comment">//表示应该立即下载脚本，但不应妨碍页面中的其他操作，比如下载其他资源或等待加载其他脚本。只对外部脚本文件有效。</span>
<span class="token operator">&lt;</span>script src<span class="token operator">=</span><span class="token string">&quot;xxx&quot;</span>  defer <span class="token operator">/</span><span class="token operator">&gt;</span> <span class="token comment">//表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。IE7 及更早版本对嵌入脚本也支持这个属性。</span>
</code></pre></div><ol start="2"><li>深拷贝的所有方法</li> <li>vuex 不同 modules 之间如何修改值</li> <li>移动屏幕适配的所有方式</li> <li>diff 算法是会遍历所有节点吗</li> <li>数据类型判断</li></ol> <h2 id="cordova"><a href="#cordova" class="header-anchor">#</a> cordova</h2> <p>架构包括三部分：</p> <ol><li>web app：html+js+css+config.xml</li> <li>webview</li> <li>cordova plugins：camera、media、storage</li></ol> <ul><li>js与native的通讯方式：iframe的形式，**通过后台启一个页面进行拦截取iframe的变更拿到js的方法给oc实现通信，iframe是依赖jssdk.js文件的，需要sdk文件作为桥梁实现通信目的。**内部实现则是通过 UIWebview＃stringByEvaluatingJavaScriptFromString的返回值 取得CommandQueue里面的参数转换成JSON数据。</li></ul> <h2 id="js-sdk-通讯方式"><a href="#js-sdk-通讯方式" class="header-anchor">#</a> js sdk 通讯方式</h2> <ul><li><p>js-sdk优化，也就是oc和js通信的一个方式。一般jssdk有三种方式实现，第一种就是常见的scheme的方式，就是我们在h5页面里面定义一些特殊的链接，拿到这个scheme之后原生拦截。然后把需要的回调函数和参数进行拦截，但这样有个问题，url一般是256个字符，有长度的限制不能无限的传递。</p> <p>**第二种是iframe的形式，通过后台启一个页面进行拦截取iframe的变更拿到js的方法给oc实现通信，iframe是依赖jssdk.js文件的，需要sdk文件作为桥梁实现通信目的。**内部实现则是通过 UIWebview＃stringByEvaluatingJavaScriptFromString的返回值 取得CommandQueue里面的参数转换成JSON数据。</p> <p>第三种是webkit的方式，他是一种直接调用的方式，无需依赖任何的sdk文件。</p></li></ul> <h2 id="纯函数"><a href="#纯函数" class="header-anchor">#</a> 纯函数</h2> <blockquote><p>相同的输入，总是会的到相同的输出，并且在执行过程中没有任何副作用。</p></blockquote> <p><strong>执行过程中没有任何副作用</strong>。</p> <p>这里我们要搞清楚什么是副作用，这里的副作用指的是函数在执行过程中产生了<strong>外部可观察变化</strong>。</p> <ol><li>发起HTTP请求</li> <li>操作DOM</li> <li>修改外部数据</li> <li>console.log()打印数据</li> <li>调用Date.now()或者Math.random()</li></ol> <h2 id="前端轮子-https-www-zhihu-com-question-29380608"><a href="#前端轮子-https-www-zhihu-com-question-29380608" class="header-anchor">#</a> 前端轮子：https://www.zhihu.com/question/29380608</h2></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新时间:</span> <span class="time">12/15/2021, 1:46:09 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/web/css/canvas 使用.html" class="prev">
        canvas 使用
      </a></span> <span class="next"><a href="/blog/web/js/errorReport.html">
        错误上报
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.016ecbb7.js" defer></script><script src="/blog/assets/js/2.928a6fe7.js" defer></script><script src="/blog/assets/js/18.05c8eb0b.js" defer></script>
  </body>
</html>
