<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>amd(运行在浏览器端) | korn的博客</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="专注 前端 技术栈分享，从前端到Node.js再到数据库">
    
    <link rel="preload" href="/blog/assets/css/0.styles.a4691601.css" as="style"><link rel="preload" href="/blog/assets/js/app.016ecbb7.js" as="script"><link rel="preload" href="/blog/assets/js/2.928a6fe7.js" as="script"><link rel="preload" href="/blog/assets/js/30.50b73b19.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.77b39606.js"><link rel="prefetch" href="/blog/assets/js/11.62e42ab5.js"><link rel="prefetch" href="/blog/assets/js/12.f45a62f5.js"><link rel="prefetch" href="/blog/assets/js/13.2602d9e7.js"><link rel="prefetch" href="/blog/assets/js/14.72eeec06.js"><link rel="prefetch" href="/blog/assets/js/15.933c999c.js"><link rel="prefetch" href="/blog/assets/js/16.fa841be8.js"><link rel="prefetch" href="/blog/assets/js/17.16734f12.js"><link rel="prefetch" href="/blog/assets/js/18.05c8eb0b.js"><link rel="prefetch" href="/blog/assets/js/19.42269bb6.js"><link rel="prefetch" href="/blog/assets/js/20.3bb5a14c.js"><link rel="prefetch" href="/blog/assets/js/21.f33e7cfe.js"><link rel="prefetch" href="/blog/assets/js/22.b073c1aa.js"><link rel="prefetch" href="/blog/assets/js/23.971df460.js"><link rel="prefetch" href="/blog/assets/js/24.7fc7e003.js"><link rel="prefetch" href="/blog/assets/js/25.4c8c73e4.js"><link rel="prefetch" href="/blog/assets/js/26.6b941ac2.js"><link rel="prefetch" href="/blog/assets/js/27.38b0556e.js"><link rel="prefetch" href="/blog/assets/js/28.c824e37c.js"><link rel="prefetch" href="/blog/assets/js/29.44a1851e.js"><link rel="prefetch" href="/blog/assets/js/3.6ab95d19.js"><link rel="prefetch" href="/blog/assets/js/4.ba3164ba.js"><link rel="prefetch" href="/blog/assets/js/5.75a3592b.js"><link rel="prefetch" href="/blog/assets/js/6.0377ba0c.js"><link rel="prefetch" href="/blog/assets/js/7.888c74f3.js"><link rel="prefetch" href="/blog/assets/js/8.c67934ea.js"><link rel="prefetch" href="/blog/assets/js/9.d9926b68.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.a4691601.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">korn的博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><span class="title">前端</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端" class="mobile-dropdown-title"><span class="title">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/web/Interview/learn.html" class="nav-link">
  面试题
</a></li><li class="dropdown-item"><!----> <a href="/blog/web/css/css.html" class="nav-link">
  css
</a></li><li class="dropdown-item"><!----> <a href="/blog/web/js/js.html" class="nav-link">
  js
</a></li><li class="dropdown-item"><!----> <a href="/blog/web/vue/vue.html" class="nav-link">
  vue
</a></li><li class="dropdown-item"><!----> <a href="/blog/web/network/network.html" class="nav-link">
  network
</a></li><li class="dropdown-item"><!----> <a href="/blog/web/webpack/learn.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  webpack
</a></li></ul></div></div><div class="nav-item"><a href="/blog/node/learn.html" class="nav-link">
  node
</a></div><div class="nav-item"><a href="/blog/dataBase/mysql/learn.html" class="nav-link">
  数据库
</a></div><div class="nav-item"><a href="/blog/git/learn.html" class="nav-link">
  git
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><span class="title">前端</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端" class="mobile-dropdown-title"><span class="title">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/web/Interview/learn.html" class="nav-link">
  面试题
</a></li><li class="dropdown-item"><!----> <a href="/blog/web/css/css.html" class="nav-link">
  css
</a></li><li class="dropdown-item"><!----> <a href="/blog/web/js/js.html" class="nav-link">
  js
</a></li><li class="dropdown-item"><!----> <a href="/blog/web/vue/vue.html" class="nav-link">
  vue
</a></li><li class="dropdown-item"><!----> <a href="/blog/web/network/network.html" class="nav-link">
  network
</a></li><li class="dropdown-item"><!----> <a href="/blog/web/webpack/learn.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  webpack
</a></li></ul></div></div><div class="nav-item"><a href="/blog/node/learn.html" class="nav-link">
  node
</a></div><div class="nav-item"><a href="/blog/dataBase/mysql/learn.html" class="nav-link">
  数据库
</a></div><div class="nav-item"><a href="/blog/git/learn.html" class="nav-link">
  git
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Interview</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>css</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>js</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>html</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>vue</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>network</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>webpack</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/web/webpack/learn.html" aria-current="page" class="active sidebar-link">learn</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h3 id="amd-运行在浏览器端"><a href="#amd-运行在浏览器端" class="header-anchor">#</a> amd(运行在浏览器端)</h3> <ul><li>需要引入 require.js</li></ul> <h3 id="common-js-运行在-node-环境"><a href="#common-js-运行在-node-环境" class="header-anchor">#</a> common.js(运行在 node 环境)</h3> <ul><li>Import 和 module.exports</li></ul> <h3 id="webpack"><a href="#webpack" class="header-anchor">#</a> webpack</h3> <h4 id="默认配置文件的名字-webpack-config-js"><a href="#默认配置文件的名字-webpack-config-js" class="header-anchor">#</a> 默认配置文件的名字 webpack.config.js</h4> <h4 id="css-抽离插件-mini-css-extract-plugin"><a href="#css-抽离插件-mini-css-extract-plugin" class="header-anchor">#</a> css 抽离插件 mini-css-extract-plugin</h4> <h4 id="webpack-dev-middleware-webpack-中间件-可以在-node-中启动-webpack-服务-用在开发时的跨域上"><a href="#webpack-dev-middleware-webpack-中间件-可以在-node-中启动-webpack-服务-用在开发时的跨域上" class="header-anchor">#</a> webpack-dev-middleware webpack 中间件,可以在 node 中启动 webpack 服务,用在开发时的跨域上</h4> <h4 id="tree-shaking-打包的时候自动把没用的代码删除"><a href="#tree-shaking-打包的时候自动把没用的代码删除" class="header-anchor">#</a> tree-shaking 打包的时候自动把没用的代码删除</h4> <h4 id="mini-css-extract-plugin-抽离写在-html-中的-css"><a href="#mini-css-extract-plugin-抽离写在-html-中的-css" class="header-anchor">#</a> <strong>mini-css-extract-plugin</strong> 抽离写在 html 中的 css</h4> <h4 id="file-loader"><a href="#file-loader" class="header-anchor">#</a> <strong>file-loader</strong></h4> <ul><li>可以用来帮助webpack打包处理一系列的图片文件；比如：<strong>.png</strong> 、 <strong>.jpg 、.jepg</strong>等格式的图片；</li> <li>使用file-loader打包的图片会给每张图片都生成一个随机的hash值作为图片的名字；</li></ul> <h4 id="url-loader"><a href="#url-loader" class="header-anchor">#</a> url-loader</h4> <ul><li>把图片文件转成 base64 的文件</li></ul> <h4 id="报错信息提示"><a href="#报错信息提示" class="header-anchor">#</a> 报错信息提示：</h4> <ol><li><code>devtool:source-map</code> <ul><li>增加映射文件，可以帮助我们调试源码，会单独生产 sourcemap 文件，出错了会标识到当前报错的行和列</li></ul></li> <li><code>devtool:eval-source-map</code> <ul><li>不会产生单独的文件，但可以显示报错的列和行</li></ul></li> <li><code>devtool:cheap-module-souce-map</code> <ul><li>不会产生列，是一个单独的映射文件</li></ul></li> <li><code>devtool:cheap-eval-source-map</code> <ul><li>不会生成文件，集成在打包后的文件中，不会产生列</li></ul></li></ol> <h3 id="webpack3-和-webpack4-的区别"><a href="#webpack3-和-webpack4-的区别" class="header-anchor">#</a> webpack3 和 webpack4 的区别</h3> <ol><li>webpack4 增加了 model 的配置（只有两种值development | production）</li> <li>CommonChunksPlugin已经从webpack4中移除。可使用optimization.splitChunks进行模块划分（提取公用代码）。</li> <li>webpack4使用MiniCssExtractPlugin取代ExtractTextWebpackPlugin。
.代码分割。</li> <li>使用动态import，而不是用system.import或者require.ensure</li> <li>vue-loader。使用vue-loader插件为.vue文件中的各部分使用相对应的loader，比如css-loader</li> <li>UglifyJsPlugin：现在也不需要使用这个plugin了，只需要使用optimization.minimize为true就行，production mode下面自动为true</li></ol> <h3 id="webpack5新特性"><a href="#webpack5新特性" class="header-anchor">#</a> webpack5新特性</h3> <p>官方描述：</p> <ol><li>使用持久化缓存提高构建性能；</li> <li>使用更好的算法和默认值改进长期缓存（long-term caching）；</li> <li>清理内部结构而不引入任何破坏性的变化；</li> <li>引入一些breaking changes，以便尽可能长的使用v5版本。</li></ol> <p>通俗版描述：</p> <ol><li>减小打包后的文件体积</li> <li>按需加载支持文件名模式</li> <li>使用long-term caching解决生产环境下moduleIds &amp; chunkIds变化的问题</li> <li>使用cache: {type: &quot;filesystem&quot;}配置实现持久化缓存，提高构建速度</li> <li>优化minSize&amp;maxSize的配置方式</li> <li>Node.js polyfills 自动加载功能被移除</li></ol> <h3 id="常用的-loader-及其作用"><a href="#常用的-loader-及其作用" class="header-anchor">#</a> 常用的 loader 及其作用：</h3> <ul><li>style-loader：将CSS添加到DOM的内联样式标签style里</li> <li>css-loader：允许将CSS文件通过require的方式引入，并返回CSS代码</li> <li>less-loader：处理less</li> <li>sass-loader：处理sass</li> <li>postcss-loader：用postcss来处理CSS</li> <li>file-loader：分发文件到output目录并返回相对路径</li> <li>url-loader 和 file-loader 类似，但是当文件小于设定的limit时可以返回一个Data Url</li> <li>html-minify-loader：压缩HTML文件</li> <li>babel-loader：把ES6文件转换成ES5文件</li></ul> <h3 id="常用插件"><a href="#常用插件" class="header-anchor">#</a> 常用插件</h3> <ul><li>HtmlWebpackPlugin 是依据一个简单的模板，帮助生成最终的 Html5 文件，这个文件中自动引用了打包后的 JS 文件。每次编译都在文件名中插入一个不同的哈希值。</li> <li><code>CopyWebpackPlugin</code> : 在 webpack 中拷贝文件和文件夹，一般用于将不需要打包的静态文件 copy 到我们最终打包的文件目录下</li></ul> <h3 id="webpack-打包优化"><a href="#webpack-打包优化" class="header-anchor">#</a> Webpack 打包优化</h3> <ol><li>DllPlugin  动态链接库</li></ol> <h3 id="webpack中-loader和plugin的区别"><a href="#webpack中-loader和plugin的区别" class="header-anchor">#</a> webpack中 loader和plugin的区别</h3> <ul><li><p>loader用于转换、将A文件进行编译形成B文件</p></li> <li><p>plugin用于处理打包过程中的自定义操作的扩展器，不直接操作文件</p></li></ul> <p>webpack 的构建流程是什么</p> <p>初始化参数：解析webpack配置参数，合并shell传入和webpack.config.js文件配置的参数,形成最后的配置结果；</p> <p>开始编译：上一步得到的参数初始化compiler对象，注册所有配置的插件，插件 监听webpack构建生命周期的事件节点，做出相应的反应，执行对象的run方法开始执行编译；</p> <p>确定入口：从配置的entry入口，开始解析文件构建AST语法树，找出依赖，递归下去；</p> <p>编译模块：递归中根据文件类型和loader配置，调用所有配置的loader对文件进行转换，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；</p> <p>完成模块编译并输出：递归完事后，得到每个文件结果，包含每个模块以及他们之间的依赖关系，根据entry或分包配置生成代码块chunk;</p> <p>输出完成：输出所有的chunk到文件系统；</p> <p>webpack 的热更新原理
其实是自己开启了express应用，添加了对webpack编译的监听，添加了和浏览器的websocket长连接，当文件变化触发webpack进行编译并完成后，会通过sokcet消息告诉浏览器准备刷新。而为了减少刷新的代价，就是不用刷新网页，而是刷新某个模块，webpack-dev-server可以支持热更新，通过生成 文件的hash值来比对需要更新的模块，浏览器再进行热替换
服务端</p> <p>启动 webpack-dev-server服务器
创建webpack实例
创建server服务器
添加webpack的done事件回调
编译完成向客户端发送消息
创建express应用app
设置文件系统为内存文件系统
添加 webpack-dev-middleware 中间件
中间件负责返回生成的文件
启动webpack编译
创建http服务器并启动服务
使用sockjs在浏览器端和服务端之间建立一个websocket长连接
创建socket服务器</p> <p>客户端</p> <p>webpack-dev-server/client端会监听到此hash消息
客户端收到ok消息后会执行reloadApp方法进行更新
在reloadApp中会进行判断，是否支持热更新，如果支持的话发生 webpackHotUpdate事件，如果不支持就直接刷新浏览器
在 webpack/hot/dev-server.js 会监听 webpackHotUpdate 事件
在check方法里会调用module.hot.check方法
HotModuleReplacement.runtime请求Manifest
通过调用 JsonpMainTemplate.runtime 的 hotDownloadManifest方法
调用JsonpMainTemplate.runtime的hotDownloadUpdateChunk方法通过JSONP请求获取最新的模块代码
补丁js取回来或会调用 JsonpMainTemplate.runtime.js 的 webpackHotUpdate 方法
然后会调用 HotModuleReplacement.runtime.js 的 hotAddUpdateChunk方法动态更新 模块代码
然后调用hotApply方法进行热更</p> <p>webpack 打包是hash码是如何生成的
1.webpack生态中存在多种计算hash的方式</p> <p>hash
chunkhash
contenthash</p> <p>hash代表每次webpack编译中生成的hash值，所有使用这种方式的文件hash都相同。每次构建都会使webpack计算新的hash。chunkhash基于入口文件及其关联的chunk形成，某个文件的改动只会影响与它有关联的chunk的hash值，不会影响其他文件contenthash根据文件内容创建。当文件内容发生变化时，contenthash发生变化
2.避免相同随机值</p> <p>webpack在计算hash后分割chunk。产生相同随机值可能是因为这些文件属于同一个chunk,可以将某个文件提到独立的chunk（如放入entry）</p> <p>webpack 离线缓存静态资源如何实现</p> <p>在配置webpack时，我们可以使用html-webpack-plugin来注入到和html一段脚本来实现将第三方或者共用资源进行 静态化存储在html中注入一段标识，例如 &lt;% HtmlWebpackPlugin.options.loading.html %&gt; ,在 html-webpack-plugin 中即可通过配置html属性，将script注入进去
利用 webpack-manifest-plugin 并通过配置 webpack-manifest-plugin ,生成 manifestjson 文件，用来对比js资源的差异，做到是否替换，当然，也要写缓存script
在我们做Cl以及CD的时候，也可以通过编辑文件流来实现静态化脚本的注入，来降低服务器的压力，提高性能
可以通过自定义plugin或者html-webpack-plugin等周期函数，动态注入前端静态化存储script</p> <p>webpack 常见的plugin有哪些</p> <p>ProvidePlugin：自动加载模块，代替require和import
html-webpack-plugin可以根据模板自动生成html代码，并自动引用css和js文件
extract-text-webpack-plugin 将js文件中引用的样式单独抽离成css文件
DefinePlugin 编译时配置全局变量，这对开发模式和发布模式的构建允许不同的行为非常有用。
HotModuleReplacementPlugin 热更新
optimize-css-assets-webpack-plugin 不同组件中重复的css可以快速去重
webpack-bundle-analyzer 一个webpack的bundle文件分析工具，将bundle文件以可交互缩放的treemap的形式展示。
compression-webpack-plugin 生产环境可采用gzip压缩JS和CSS
happypack：通过多进程模型，来加速代码构建
clean-wenpack-plugin 清理每次打包下没有使用的文件
speed-measure-webpack-plugin:可以看至U每个Loader和Plugin执行耗时（整个扌丁包耗时、每个Plugin和 Loader 耗时）
webpack-bundle-analyzer:可视化Webpack输出文件的体积（业务组件、依赖第三方模块</p> <p>webpack 插件如何实现</p> <p>webpack本质是一个事件流机制，核心模块：tabable(Sync + Async)Hooks 构造出 === Compiler(编译) + Compiletion(创建bundles)
compiler对象代表了完整的webpack环境配置。这个对象在启动webpack时被一次性建立，并配置好所有可操作的设置，包括options、loader和plugin。当在webpack环境中应用一插件时，插件将收到此compiler对象的引用。可以使用它来访问webpack的主环境
compilation对象代表了一次资源版本构建。当运行webpack开发环境中间件时，每当检测到一个文件变化，就会创建一个新的compilation,从而生成一个新的编译资源。一个compilation对象表现了当前的模块资源、编译生成资源、变化的文件、以及被跟踪依赖的状态的信息。compilation对象也提供了很多关键时机的回调，以供插件做自定义处理时选择使用
创建一个插件函数，在其prototype上定义apply方法，指定一个webpack自身的事件钩子
函数内部处理webpack内部实例的特定数据
处理完成后，调用webpack提供的回调函数</p> <p>function MyWebpackPlugin()(
}；
// prototype 上定义 apply 方法
MyWebpackPlugin.prototype.apply=function(){
// 指定一个事件函数挂载到webpack
compiler.pluginCwebpacksEventHook&quot;funcion (compiler)( console. log(“这是一个插件”)；
// 功能完成调用后webpack提供的回调函数
callback()
})
复制代码
webpack有哪些常⻅的Loader</p> <p>file-loader：把⽂件输出到⼀个⽂件夹中，在代码中通过相对 URL 去引⽤输出的⽂件
url-loader：和 file-loader 类似，但是能在⽂件很⼩的情况下以 base64 的⽅式把⽂件内容注⼊到代码中去
source-map-loader：加载额外的 Source Map ⽂件，以⽅便断点调试
image-loader：加载并且压缩图⽚⽂件
babel-loader：把 ES6 转换成 ES5
css-loader：加载 CSS，⽀持模块化、压缩、⽂件导⼊等特性
style-loader：把 CSS 代码注⼊到 JavaScript 中，通过 DOM 操作去加载 CSS。
eslint-loader：通过 ESLint 检查 JavaScript 代码</p> <p>webpack如何实现持久化缓存</p> <p>服务端设置http缓存头（cache-control）
打包依赖和运行时到不同的chunk，即作为splitChunk,因为他们几乎是不变的
延迟加载：使用import()方式，可以动态加载的文件分到独立的chunk,以得到自己的chunkhash
保持hash值的稳定：编译过程和文件内通的更改尽量不影响其他文件hash的计算，对于低版本webpack生成的增量数字id不稳定问题，可用hashedModuleIdsPlugin基于文件路径生成解决</p> <p>如何⽤webpack来优化前端性能？
⽤webpack优化前端性能是指优化webpack的输出结果，让打包的最终结果在浏览器运⾏快速⾼效。</p> <p>压缩代码：删除多余的代码、注释、简化代码的写法等等⽅式。可以利⽤webpack的 UglifyJsPlugin 和 ParallelUglifyPlugin 来压缩JS⽂件， 利⽤ cssnano （css-loader?minimize）来压缩css
利⽤CDN加速: 在构建过程中，将引⽤的静态资源路径修改为CDN上对应的路径。可以利⽤webpack对于 output 参数和各loader的 publicPath 参数来修改资源路径
Tree Shaking: 将代码中永远不会⾛到的⽚段删除掉。可以通过在启动webpack时追加参数 --optimize-minimize 来实现
Code Splitting: 将代码按路由维度或者组件分块(chunk),这样做到按需加载,同时可以充分利⽤浏览器缓存
提取公共第三⽅库: SplitChunksPlugin插件来进⾏公共模块抽取,利⽤浏览器缓存可以⻓期缓存这些⽆需频繁变动的公共代码</p> <p>webpack treeShaking机制的原理</p> <p>treeShaking 也叫摇树优化，是一种通过移除多于代码，来优化打包体积的，生产环境默认开启。
可以在代码不运行的状态下，分析出不需要的代码；
利用es6模块的规范</p> <p>ES6 Module引入进行静态分析，故而编译的时候正确判断到底加载了那些模块
静态分析程序流，判断那些模块和变量未被使用或者引用，进而删除对应代码</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新时间:</span> <span class="time">12/15/2021, 1:46:09 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/web/network/network.html" class="prev">
        网络
      </a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.016ecbb7.js" defer></script><script src="/blog/assets/js/2.928a6fe7.js" defer></script><script src="/blog/assets/js/30.50b73b19.js" defer></script>
  </body>
</html>
