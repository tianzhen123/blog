<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>korn的博客</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="专注 前端 技术栈分享，从前端到Node.js再到数据库">
    
    <link rel="preload" href="/blog/assets/css/0.styles.a4691601.css" as="style"><link rel="preload" href="/blog/assets/js/app.016ecbb7.js" as="script"><link rel="preload" href="/blog/assets/js/2.928a6fe7.js" as="script"><link rel="preload" href="/blog/assets/js/22.b073c1aa.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.77b39606.js"><link rel="prefetch" href="/blog/assets/js/11.62e42ab5.js"><link rel="prefetch" href="/blog/assets/js/12.f45a62f5.js"><link rel="prefetch" href="/blog/assets/js/13.2602d9e7.js"><link rel="prefetch" href="/blog/assets/js/14.72eeec06.js"><link rel="prefetch" href="/blog/assets/js/15.933c999c.js"><link rel="prefetch" href="/blog/assets/js/16.fa841be8.js"><link rel="prefetch" href="/blog/assets/js/17.16734f12.js"><link rel="prefetch" href="/blog/assets/js/18.05c8eb0b.js"><link rel="prefetch" href="/blog/assets/js/19.42269bb6.js"><link rel="prefetch" href="/blog/assets/js/20.3bb5a14c.js"><link rel="prefetch" href="/blog/assets/js/21.f33e7cfe.js"><link rel="prefetch" href="/blog/assets/js/23.971df460.js"><link rel="prefetch" href="/blog/assets/js/24.7fc7e003.js"><link rel="prefetch" href="/blog/assets/js/25.4c8c73e4.js"><link rel="prefetch" href="/blog/assets/js/26.6b941ac2.js"><link rel="prefetch" href="/blog/assets/js/27.38b0556e.js"><link rel="prefetch" href="/blog/assets/js/28.c824e37c.js"><link rel="prefetch" href="/blog/assets/js/29.44a1851e.js"><link rel="prefetch" href="/blog/assets/js/3.6ab95d19.js"><link rel="prefetch" href="/blog/assets/js/30.50b73b19.js"><link rel="prefetch" href="/blog/assets/js/4.ba3164ba.js"><link rel="prefetch" href="/blog/assets/js/5.75a3592b.js"><link rel="prefetch" href="/blog/assets/js/6.0377ba0c.js"><link rel="prefetch" href="/blog/assets/js/7.888c74f3.js"><link rel="prefetch" href="/blog/assets/js/8.c67934ea.js"><link rel="prefetch" href="/blog/assets/js/9.d9926b68.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.a4691601.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">korn的博客</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><span class="title">前端</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端" class="mobile-dropdown-title"><span class="title">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/web/Interview/learn.html" class="nav-link">
  面试题
</a></li><li class="dropdown-item"><!----> <a href="/blog/web/css/css.html" class="nav-link">
  css
</a></li><li class="dropdown-item"><!----> <a href="/blog/web/js/js.html" class="nav-link">
  js
</a></li><li class="dropdown-item"><!----> <a href="/blog/web/vue/vue.html" class="nav-link">
  vue
</a></li><li class="dropdown-item"><!----> <a href="/blog/web/network/network.html" class="nav-link">
  network
</a></li><li class="dropdown-item"><!----> <a href="/blog/web/webpack/learn.html" class="nav-link">
  webpack
</a></li></ul></div></div><div class="nav-item"><a href="/blog/node/learn.html" class="nav-link">
  node
</a></div><div class="nav-item"><a href="/blog/dataBase/mysql/learn.html" class="nav-link">
  数据库
</a></div><div class="nav-item"><a href="/blog/git/learn.html" class="nav-link">
  git
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">
  主页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><span class="title">前端</span> <span class="arrow down"></span></button> <button type="button" aria-label="前端" class="mobile-dropdown-title"><span class="title">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/web/Interview/learn.html" class="nav-link">
  面试题
</a></li><li class="dropdown-item"><!----> <a href="/blog/web/css/css.html" class="nav-link">
  css
</a></li><li class="dropdown-item"><!----> <a href="/blog/web/js/js.html" class="nav-link">
  js
</a></li><li class="dropdown-item"><!----> <a href="/blog/web/vue/vue.html" class="nav-link">
  vue
</a></li><li class="dropdown-item"><!----> <a href="/blog/web/network/network.html" class="nav-link">
  network
</a></li><li class="dropdown-item"><!----> <a href="/blog/web/webpack/learn.html" class="nav-link">
  webpack
</a></li></ul></div></div><div class="nav-item"><a href="/blog/node/learn.html" class="nav-link">
  node
</a></div><div class="nav-item"><a href="/blog/dataBase/mysql/learn.html" class="nav-link">
  数据库
</a></div><div class="nav-item"><a href="/blog/git/learn.html" class="nav-link">
  git
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Interview</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/web/Interview/learn.html" class="sidebar-link">常考面试题</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>css</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>js</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>html</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>vue</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>network</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>webpack</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><p>[TOC]</p> <h3 id="react-生命周期有哪些"><a href="#react-生命周期有哪些" class="header-anchor">#</a> React 生命周期有哪些？</h3> <ul><li><p>React 16.3 以前的版本：</p> <ul><li><strong>componentWillMount：</strong> 在渲染之前执行，用于根组件中的应用程序级别配置。</li> <li><strong>componentDidMount：</strong> 在首次渲染之后执行，所有 AJAX 请求，DOM 或状态更新以及设置事件侦听器都应在此执行。</li> <li><strong>componentWillReceiveProps：</strong> 在特定属性更新以触发状态转换时执行。</li> <li><strong>shouldComponentUpdate：</strong> 确定是否要更新组件。默认情况下，它返回 <code>true</code>。如果你确定在状态或属性更新后不需要渲染组件，则可以返回 <code>false</code> 值。这是提高性能的好地方，因为如果组件收到新的 <code>props</code>，它可以防止重新渲染。</li> <li><strong>componentWillUpdate：</strong> 当有属性或状态改变被<code>shouldComponentUpdate()</code> 确认并返回 <code>true</code> 时，在重新渲染组件之前执行。</li> <li><strong>componentDidUpdate：</strong> 通常，它用于响应属性或状态更改来更新 DOM。</li> <li><strong>componentWillUnmount：</strong> 它将用于取消任何传出的网络请求，或删除与该组件关联的所有事件侦听器。</li></ul> <p>React 16.3+ 版本</p> <ul><li><strong>getDerivedStateFromProps：</strong> 在调用 <code>render()</code> 之前被调用，并且在每次渲染中都会被调用。对于需要派生状态的罕见用例，这是存在的。<a href="https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html" target="_blank" rel="noopener noreferrer">如果您需要派生状态<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 值得一读。</li> <li><strong>componentDidMount：</strong> 在首次渲染之后执行，并且所有 AJAX 请求、DOM 或状态更新以及设置事件侦听器都应在此发生。</li> <li><strong>shouldComponentUpdate：</strong> 确定是否将更新组件。默认情况下，它返回 <code>true</code>。如果你确定在状态或属性更新后不需要渲染组件，则可以返回 <code>false</code>值。这是提高性能的好地方，因为如果组件接收到新的属性，它可以防止重新渲染。</li> <li><strong>getSnapshotBeforeUpdate：</strong> 在将呈现的输出提交给 DOM 之前立即执行。此方法返回的任何值都将传递到 <code>componentDidUpdate()</code> 中。 这对于从 DOM（即滚动位置）捕获信息很有用。</li> <li><strong>componentDidUpdate：</strong> 通常，它用于响应属性或状态更改来更新DOM。如果 <code>shouldComponentUpdate()</code> 返回 <code>false</code>，则不会触发。</li> <li><strong>componentWillUnmount：</strong> 它将用于取消任何传出的网络请求，或删除与该组件关联的所有事件侦听器。</li></ul></li></ul> <h3 id="组件生命周期有哪些不同阶段"><a href="#组件生命周期有哪些不同阶段" class="header-anchor">#</a> 组件生命周期有哪些不同阶段？</h3> <p>组件生命周期具有三个不同的生命周期阶段。</p> <ol><li><strong>Mounting：</strong> 组件已准备好安装在浏览器 DOM 中。这个阶段涵盖了生命周期方法 <code>constructor()</code>、<code>getDerivedStateFromProps()</code>、 <code>render()</code> 和 <code>componentDidMount()</code> 的初始化。</li> <li><strong>Updating：</strong> 在此阶段，组件以两种方式进行更新，即发送新 <code>props</code> 和从 <code>setState()</code> 或 <code>forceUpdate()</code> 更新状态。此阶段涵盖了<code>getDerivedStateFromProps()</code>，<code>shouldComponentUpdate()</code>，<code>render()</code> 、<code>getSnapshotBeforeUpdate()</code> 和 <code>componentDidUpdate()</code> 生命周期方法。</li> <li><strong>Unmounting：</strong> 在最后一个阶段，不再需要该组件并从浏览器DOM上卸载该组件。 这个阶段包括 <code>componentWillUnmount()</code> 生命周期方法。</li></ol> <p>值得一提的是，在将更改应用于 DOM 时，React 内部具有阶段性概念。 它们分开如下</p> <ol><li><strong>Render：</strong> 该组件将渲染而没有任何副作用。这适用于 Pure 组件，在此阶段，React 可以暂停、中止或重新启动渲染。</li> <li><strong>Pre-commit：</strong> 在组件将更改实际应用于 DOM 之前，有一段时间可以让 React 通过 <code>getSnapshotBeforeUpdate()</code> 从 DOM 中读取内容。</li> <li><strong>Commit：</strong> React 与 DOM 一起工作并分别执行最终的生命周期：<code>componentDidMount()</code> 用于安装，<code>componentDidUpdate()</code> 用于更新，以及 <code>componentWillUnmount()</code> 用于卸载。</li></ol> <h3 id="高阶组件是什么"><a href="#高阶组件是什么" class="header-anchor">#</a> 高阶组件是什么</h3> <p>高阶组件（HOC）是接收组件并返回新组件的函数。基本上，这是从 React 的组成性质衍生出来的一种模式。</p> <p>我们称它们为纯组件，因为它们可以接受任何动态提供的子组件，但是它们不会修改或复制其输入组件中的任何行为。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> EnhancedComponent <span class="token operator">=</span> <span class="token function">higherOrderComponent</span><span class="token punctuation">(</span>WrappedComponent<span class="token punctuation">)</span>
</code></pre></div><p>HOC 可以用到很多场景中：</p> <ol><li>代码重用，逻辑和引导程序抽象。</li> <li>渲染劫持。</li> <li>状态抽象和操纵。</li> <li>props操作。</li></ol> <h3 id="pure-components-是什么"><a href="#pure-components-是什么" class="header-anchor">#</a> Pure Components 是什么</h3> <p><code>React.PureComponent</code> 与 <code>React.Component</code> 几乎完全相同，不同之处在于它为你处理了 <code>shouldComponentUpdate()</code> 方法。当 props 和 state 改变时，PureComponent 将对 props 和 state 进行浅表比较。另一方面，Component 初始不会将当前 props 和 state 与nextPorps 和 nextState 进行比较。因此，每当调用 <code>shouldComponentUpdate</code> 时，组件将默认重新渲染</p> <h3 id="react-hook"><a href="#react-hook" class="header-anchor">#</a> React HOOK</h3> <ul><li>useState定义数据</li> <li>useEffect使用生命周期
<ul><li>如果你熟悉 React class 的生命周期函数，你可以把 <code>useEffect</code> Hook 看做 <code>componentDidMount</code>，<code>componentDidUpdate</code> 和 <code>componentWillUnmount</code> 这三个函数的组合。</li></ul></li> <li>useMemo 相当于 React.PureComponent</li> <li>useCallback 该函数仅在某个依赖项改变时才会更新
<ul><li><code>useCallback(fn, deps)</code> 相当于 <code>useMemo(() =&gt; fn, deps)</code></li> <li>第一个参数是变化的回调函数，第二个参数是个数组，当数组中传入的值发生变化时，回调函数才会执行</li></ul></li> <li>useReducer
<ul><li><a href="https://react.docschina.org/docs/hooks-reference.html#usestate" target="_blank" rel="noopener noreferrer"><code>useState</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 的替代方案。它接收一个形如 <code>(state, action) =&gt; newState</code> 的 reducer，并返回当前的 state 以及与其配套的 <code>dispatch</code> 方法</li></ul></li></ul></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新时间:</span> <span class="time">4/7/2021, 10:44:31 AM</span></div></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.016ecbb7.js" defer></script><script src="/blog/assets/js/2.928a6fe7.js" defer></script><script src="/blog/assets/js/22.b073c1aa.js" defer></script>
  </body>
</html>
