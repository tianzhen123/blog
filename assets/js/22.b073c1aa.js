(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{379:function(e,t,o){"use strict";o.r(t);var v=o(44),_=Object(v.a)({},(function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("p",[e._v("[TOC]")]),e._v(" "),o("h3",{attrs:{id:"react-生命周期有哪些"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#react-生命周期有哪些"}},[e._v("#")]),e._v(" React 生命周期有哪些？")]),e._v(" "),o("ul",[o("li",[o("p",[e._v("React 16.3 以前的版本：")]),e._v(" "),o("ul",[o("li",[o("strong",[e._v("componentWillMount：")]),e._v(" 在渲染之前执行，用于根组件中的应用程序级别配置。")]),e._v(" "),o("li",[o("strong",[e._v("componentDidMount：")]),e._v(" 在首次渲染之后执行，所有 AJAX 请求，DOM 或状态更新以及设置事件侦听器都应在此执行。")]),e._v(" "),o("li",[o("strong",[e._v("componentWillReceiveProps：")]),e._v(" 在特定属性更新以触发状态转换时执行。")]),e._v(" "),o("li",[o("strong",[e._v("shouldComponentUpdate：")]),e._v(" 确定是否要更新组件。默认情况下，它返回 "),o("code",[e._v("true")]),e._v("。如果你确定在状态或属性更新后不需要渲染组件，则可以返回 "),o("code",[e._v("false")]),e._v(" 值。这是提高性能的好地方，因为如果组件收到新的 "),o("code",[e._v("props")]),e._v("，它可以防止重新渲染。")]),e._v(" "),o("li",[o("strong",[e._v("componentWillUpdate：")]),e._v(" 当有属性或状态改变被"),o("code",[e._v("shouldComponentUpdate()")]),e._v(" 确认并返回 "),o("code",[e._v("true")]),e._v(" 时，在重新渲染组件之前执行。")]),e._v(" "),o("li",[o("strong",[e._v("componentDidUpdate：")]),e._v(" 通常，它用于响应属性或状态更改来更新 DOM。")]),e._v(" "),o("li",[o("strong",[e._v("componentWillUnmount：")]),e._v(" 它将用于取消任何传出的网络请求，或删除与该组件关联的所有事件侦听器。")])]),e._v(" "),o("p",[e._v("React 16.3+ 版本")]),e._v(" "),o("ul",[o("li",[o("strong",[e._v("getDerivedStateFromProps：")]),e._v(" 在调用 "),o("code",[e._v("render()")]),e._v(" 之前被调用，并且在每次渲染中都会被调用。对于需要派生状态的罕见用例，这是存在的。"),o("a",{attrs:{href:"https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("如果您需要派生状态"),o("OutboundLink")],1),e._v(" 值得一读。")]),e._v(" "),o("li",[o("strong",[e._v("componentDidMount：")]),e._v(" 在首次渲染之后执行，并且所有 AJAX 请求、DOM 或状态更新以及设置事件侦听器都应在此发生。")]),e._v(" "),o("li",[o("strong",[e._v("shouldComponentUpdate：")]),e._v(" 确定是否将更新组件。默认情况下，它返回 "),o("code",[e._v("true")]),e._v("。如果你确定在状态或属性更新后不需要渲染组件，则可以返回 "),o("code",[e._v("false")]),e._v("值。这是提高性能的好地方，因为如果组件接收到新的属性，它可以防止重新渲染。")]),e._v(" "),o("li",[o("strong",[e._v("getSnapshotBeforeUpdate：")]),e._v(" 在将呈现的输出提交给 DOM 之前立即执行。此方法返回的任何值都将传递到 "),o("code",[e._v("componentDidUpdate()")]),e._v(" 中。 这对于从 DOM（即滚动位置）捕获信息很有用。")]),e._v(" "),o("li",[o("strong",[e._v("componentDidUpdate：")]),e._v(" 通常，它用于响应属性或状态更改来更新DOM。如果 "),o("code",[e._v("shouldComponentUpdate()")]),e._v(" 返回 "),o("code",[e._v("false")]),e._v("，则不会触发。")]),e._v(" "),o("li",[o("strong",[e._v("componentWillUnmount：")]),e._v(" 它将用于取消任何传出的网络请求，或删除与该组件关联的所有事件侦听器。")])])])]),e._v(" "),o("h3",{attrs:{id:"组件生命周期有哪些不同阶段"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#组件生命周期有哪些不同阶段"}},[e._v("#")]),e._v(" 组件生命周期有哪些不同阶段？")]),e._v(" "),o("p",[e._v("组件生命周期具有三个不同的生命周期阶段。")]),e._v(" "),o("ol",[o("li",[o("strong",[e._v("Mounting：")]),e._v(" 组件已准备好安装在浏览器 DOM 中。这个阶段涵盖了生命周期方法 "),o("code",[e._v("constructor()")]),e._v("、"),o("code",[e._v("getDerivedStateFromProps()")]),e._v("、 "),o("code",[e._v("render()")]),e._v(" 和 "),o("code",[e._v("componentDidMount()")]),e._v(" 的初始化。")]),e._v(" "),o("li",[o("strong",[e._v("Updating：")]),e._v(" 在此阶段，组件以两种方式进行更新，即发送新 "),o("code",[e._v("props")]),e._v(" 和从 "),o("code",[e._v("setState()")]),e._v(" 或 "),o("code",[e._v("forceUpdate()")]),e._v(" 更新状态。此阶段涵盖了"),o("code",[e._v("getDerivedStateFromProps()")]),e._v("，"),o("code",[e._v("shouldComponentUpdate()")]),e._v("，"),o("code",[e._v("render()")]),e._v(" 、"),o("code",[e._v("getSnapshotBeforeUpdate()")]),e._v(" 和 "),o("code",[e._v("componentDidUpdate()")]),e._v(" 生命周期方法。")]),e._v(" "),o("li",[o("strong",[e._v("Unmounting：")]),e._v(" 在最后一个阶段，不再需要该组件并从浏览器DOM上卸载该组件。 这个阶段包括 "),o("code",[e._v("componentWillUnmount()")]),e._v(" 生命周期方法。")])]),e._v(" "),o("p",[e._v("值得一提的是，在将更改应用于 DOM 时，React 内部具有阶段性概念。 它们分开如下")]),e._v(" "),o("ol",[o("li",[o("strong",[e._v("Render：")]),e._v(" 该组件将渲染而没有任何副作用。这适用于 Pure 组件，在此阶段，React 可以暂停、中止或重新启动渲染。")]),e._v(" "),o("li",[o("strong",[e._v("Pre-commit：")]),e._v(" 在组件将更改实际应用于 DOM 之前，有一段时间可以让 React 通过 "),o("code",[e._v("getSnapshotBeforeUpdate()")]),e._v(" 从 DOM 中读取内容。")]),e._v(" "),o("li",[o("strong",[e._v("Commit：")]),e._v(" React 与 DOM 一起工作并分别执行最终的生命周期："),o("code",[e._v("componentDidMount()")]),e._v(" 用于安装，"),o("code",[e._v("componentDidUpdate()")]),e._v(" 用于更新，以及 "),o("code",[e._v("componentWillUnmount()")]),e._v(" 用于卸载。")])]),e._v(" "),o("h3",{attrs:{id:"高阶组件是什么"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#高阶组件是什么"}},[e._v("#")]),e._v(" 高阶组件是什么")]),e._v(" "),o("p",[e._v("高阶组件（HOC）是接收组件并返回新组件的函数。基本上，这是从 React 的组成性质衍生出来的一种模式。")]),e._v(" "),o("p",[e._v("我们称它们为纯组件，因为它们可以接受任何动态提供的子组件，但是它们不会修改或复制其输入组件中的任何行为。")]),e._v(" "),o("div",{staticClass:"language-javascript extra-class"},[o("pre",{pre:!0,attrs:{class:"language-javascript"}},[o("code",[o("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("const")]),e._v(" EnhancedComponent "),o("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),o("span",{pre:!0,attrs:{class:"token function"}},[e._v("higherOrderComponent")]),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("WrappedComponent"),o("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n")])])]),o("p",[e._v("HOC 可以用到很多场景中：")]),e._v(" "),o("ol",[o("li",[e._v("代码重用，逻辑和引导程序抽象。")]),e._v(" "),o("li",[e._v("渲染劫持。")]),e._v(" "),o("li",[e._v("状态抽象和操纵。")]),e._v(" "),o("li",[e._v("props操作。")])]),e._v(" "),o("h3",{attrs:{id:"pure-components-是什么"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#pure-components-是什么"}},[e._v("#")]),e._v(" Pure Components 是什么")]),e._v(" "),o("p",[o("code",[e._v("React.PureComponent")]),e._v(" 与 "),o("code",[e._v("React.Component")]),e._v(" 几乎完全相同，不同之处在于它为你处理了 "),o("code",[e._v("shouldComponentUpdate()")]),e._v(" 方法。当 props 和 state 改变时，PureComponent 将对 props 和 state 进行浅表比较。另一方面，Component 初始不会将当前 props 和 state 与nextPorps 和 nextState 进行比较。因此，每当调用 "),o("code",[e._v("shouldComponentUpdate")]),e._v(" 时，组件将默认重新渲染")]),e._v(" "),o("h3",{attrs:{id:"react-hook"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#react-hook"}},[e._v("#")]),e._v(" React HOOK")]),e._v(" "),o("ul",[o("li",[e._v("useState定义数据")]),e._v(" "),o("li",[e._v("useEffect使用生命周期\n"),o("ul",[o("li",[e._v("如果你熟悉 React class 的生命周期函数，你可以把 "),o("code",[e._v("useEffect")]),e._v(" Hook 看做 "),o("code",[e._v("componentDidMount")]),e._v("，"),o("code",[e._v("componentDidUpdate")]),e._v(" 和 "),o("code",[e._v("componentWillUnmount")]),e._v(" 这三个函数的组合。")])])]),e._v(" "),o("li",[e._v("useMemo 相当于 React.PureComponent")]),e._v(" "),o("li",[e._v("useCallback 该函数仅在某个依赖项改变时才会更新\n"),o("ul",[o("li",[o("code",[e._v("useCallback(fn, deps)")]),e._v(" 相当于 "),o("code",[e._v("useMemo(() => fn, deps)")])]),e._v(" "),o("li",[e._v("第一个参数是变化的回调函数，第二个参数是个数组，当数组中传入的值发生变化时，回调函数才会执行")])])]),e._v(" "),o("li",[e._v("useReducer\n"),o("ul",[o("li",[o("a",{attrs:{href:"https://react.docschina.org/docs/hooks-reference.html#usestate",target:"_blank",rel:"noopener noreferrer"}},[o("code",[e._v("useState")]),o("OutboundLink")],1),e._v(" 的替代方案。它接收一个形如 "),o("code",[e._v("(state, action) => newState")]),e._v(" 的 reducer，并返回当前的 state 以及与其配套的 "),o("code",[e._v("dispatch")]),e._v(" 方法")])])])])])}),[],!1,null,null,null);t.default=_.exports}}]);