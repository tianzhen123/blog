(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{372:function(t,a,s){"use strict";s.r(a);var n=s(44),e=Object(n.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"single-spa"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#single-spa"}},[t._v("#")]),t._v(" single-spa")]),t._v(" "),s("h2",{attrs:{id:"qiankun"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#qiankun"}},[t._v("#")]),t._v(" "),s("a",{attrs:{href:"https://qiankun.umijs.org/zh",target:"_blank",rel:"noopener noreferrer"}},[t._v("Qiankun"),s("OutboundLink")],1)]),t._v(" "),s("p",[t._v("实现原理https://blog.csdn.net/qq_41694291/article/details/113842872")]),t._v(" "),s("p",[t._v("微前端架构具备以下几个核心价值：")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("技术栈无关\n主框架不限制接入应用的技术栈，微应用具备完全自主权")])]),t._v(" "),s("li",[s("p",[t._v("独立开发、独立部署\n微应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新")])]),t._v(" "),s("li",[s("p",[t._v("增量升级")]),t._v(" "),s("p",[t._v("在面对各种复杂场景时，我们通常很难对一个已经存在的系统做全量的技术栈升级或重构，而微前端是一种非常好的实施渐进式重构的手段和策略")])]),t._v(" "),s("li",[s("p",[t._v("独立运行时\n每个微应用之间状态隔离，运行时状态不共享")])])]),t._v(" "),s("h3",{attrs:{id:"基于-shadow-dom-的样式隔离"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#基于-shadow-dom-的样式隔离"}},[t._v("#")]),t._v(" 基于 shadow DOM 的样式隔离")]),t._v(" "),s("p",[t._v("样式隔离也是微前端面临的一个重要问题，在 qiankun@1.x 中，我们支持了微应用之间的样式隔离（仅沙箱开启时生效），这尚存一些问题：")]),t._v(" "),s("ol",[s("li",[t._v("主子应用之间的样式隔离依赖手动配置插件处理")]),t._v(" "),s("li",[t._v("多应用场景下微应用之间的样式隔离亟待处理")])]),t._v(" "),s("p",[t._v("为此，我们引入了一个新的选项， "),s("code",[t._v("sandbox: { strictStyleIsolation?: boolean }")]),t._v(" 。")]),t._v(" "),s("p",[t._v("在该选项开启的情况下，我们会以 Shadow DOM 的形式嵌入微应用，以此来做到应用样式的真正隔离：")]),t._v(" "),s("div",{staticClass:"language-ts extra-class"},[s("pre",{pre:!0,attrs:{class:"language-ts"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" loadMicroApp "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'qiankun'")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("loadMicroApp")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("xxx"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" sandbox"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" strictStyleIsolation"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("true")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),s("h3",{attrs:{id:"目前微前端解决方案"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#目前微前端解决方案"}},[t._v("#")]),t._v(" 目前微前端解决方案")]),t._v(" "),s("ol",[s("li",[t._v("iframe：是传统的微前端解决方案，基于iframe标签实现，技术难度低，隔离性和兼容性很好，但是性能和使用体验比较差，多用于集成第三方系统；")]),t._v(" "),s("li",[t._v("基座模式：主要基于路由分发，即由一个基座应用来监听路由，并按照路由规则来加载不同的应用，以实现应用间解耦；（single-spa,qiankun）")]),t._v(" "),s("li",[t._v("组合式集成：把组件单独打包和发布，然后在构建或运行时组合；")]),t._v(" "),s("li",[t._v("EMP：基于Webpack5 Module Federation，一种去中心化的微前端实现方案，它不仅能很好地隔离应用，还可以轻松实现应用间的资源共享和通信；")]),t._v(" "),s("li",[t._v("Web Components：是官方提出的组件化方案，它通过对组件进行更高程度的封装，来实现微前端，但是目前兼容性不够好，尚未普及。")])]),t._v(" "),s("p",[t._v("总的来说，iframe主要用于简单并且性能要求不高的第三方系统；组合式集成目前主要用于前端组件化，而不是微前端；基座模式、EMP和Web Components是目前主流的微前端方案。")]),t._v(" "),s("h3",{attrs:{id:"qiankun实现原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#qiankun实现原理"}},[t._v("#")]),t._v(" qiankun实现原理")]),t._v(" "),s("p",[t._v("qiankun主要采用HTML Entry模式，直接将子应用打出来 HTML作为入口，主框架可以通过 fetch html 的方式获取子应用的静态资源，同时将 HTML document 作为子节点塞到主框架的容器中。这样不仅可以极大的减少主应用的接入成本，子应用的开发方式及打包方式基本上也不需要调整，而且可以天然的解决子应用之间样式隔离的问题。")]),t._v(" "),s("p",[t._v("一般来说，微前端需要解决的问题分为两大类：")]),t._v(" "),s("ol",[s("li",[s("strong",[t._v("应用的加载与切换")])]),t._v(" "),s("li",[s("strong",[t._v("应用的隔离与通信")])])]),t._v(" "),s("p",[t._v("应用的加载与切换需要解决的问题包括："),s("strong",[t._v("路由问题、应用入口、应用加载")]),t._v("；应用的隔离与通信需要解决的问题包括："),s("strong",[t._v("js隔离、css样式隔离、应用间通信")]),t._v("。")]),t._v(" "),s("ol",[s("li",[s("p",[s("strong",[t._v("应用加载")])]),t._v(" "),s("p",[s("code",[t._v("qiankun")]),t._v("使用"),s("code",[t._v("import-html-entry")]),t._v("加载应用入口")])])]),t._v(" "),s("p",[t._v("single-spa很好地解决了路由和应用入口两个问题，但并没有解决应用加载问题，而是将该问题暴露出来由使用者实现（一般可以用system.js或原生script标签来实现）；qiankun在此基础上封装了一个应用加载方案（即import-html-entry），并给出了js隔离、css样式隔离和应用间通信三个问题的解决方案，同时提供了预加载功能。")]),t._v(" "),s("p",[t._v("从目前微前端的发展来看，webpack5的Module Federation可能会成为一个焦点功能，用于解决微前端应用间的资源共享问题（EMP已经做到了这一点，qiankun的维护者也表示会集成这一功能）。当然了，随着Web Components功能的不断增强，也许浏览器本身就是微前端最完美的运行时容器。除了运行时容器，本文开篇提到的版本管理、质量管控、配置下发、线上监控、灰度发布、安全监测等，也必将成为微前端领域接下来要重点解决的问题。")])])}),[],!1,null,null,null);a.default=e.exports}}]);