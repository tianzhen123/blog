(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{366:function(t,i,n){"use strict";n.r(i);var o=n(44),e=Object(o.a)({},(function(){var t=this,i=t.$createElement,n=t._self._c||i;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h2",{attrs:{id:"git"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#git"}},[t._v("#")]),t._v(" git")]),t._v(" "),n("h3",{attrs:{id:"常用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#常用"}},[t._v("#")]),t._v(" 常用")]),t._v(" "),n("ol",[n("li",[t._v("git 删除本地分支：git branch -D [branch_name]")]),t._v(" "),n("li",[t._v("git 删除远程分支：git push origin --delete [branch_name]")]),t._v(" "),n("li",[t._v("git 把本地分支推送到远程：git push --set-upstream origin new_branch")]),t._v(" "),n("li",[t._v("git 取消合并：git reset --hard HEAD")]),t._v(" "),n("li",[t._v("git 撤销本地commit：git reset --soft HEAD^")]),t._v(" "),n("li",[t._v("git 更新本地分支：git remote update origin --prune")]),t._v(" "),n("li",[t._v("git 远程前置覆盖本地：git fetch --all && git reset --hard origin/[branch_name] && git pull")]),t._v(" "),n("li",[t._v("git 回滚到某个版本：git reset --hard [branch_version]")]),t._v(" "),n("li",[t._v("git 把本地强制覆盖到远程：git push -f -u origin [branch_name]")]),t._v(" "),n("li",[t._v("Git 拉取某一次提交的代码版本到本地分支：git checkout -b 分之名 远程仓库的commitId")])]),t._v(" "),n("h3",{attrs:{id:"git暂存管理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#git暂存管理"}},[t._v("#")]),t._v(" Git暂存管理")]),t._v(" "),n("ol",[n("li",[t._v("git stash                        # 暂存")]),t._v(" "),n("li",[t._v("git stash list                   # 列所有stash")]),t._v(" "),n("li",[t._v("git stash apply                  # 恢复暂存的内容")]),t._v(" "),n("li",[t._v("git stash drop                   # 删除暂存区")])]),t._v(" "),n("h2",{attrs:{id:"git远程分支管理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#git远程分支管理"}},[t._v("#")]),t._v(" #Git远程分支管理")]),t._v(" "),n("ol",[n("li",[t._v("git pull                         # 抓取远程仓库所有分支更新并合并到本地")]),t._v(" "),n("li",[t._v("git pull --no-ff                 # 抓取远程仓库所有分支更新并合并到本地，不要快进合并")]),t._v(" "),n("li",[t._v("git fetch origin                 # 抓取远程仓库更新")]),t._v(" "),n("li",[t._v("git merge origin/master          # 将远程主分支合并到本地当前分支")]),t._v(" "),n("li",[t._v("git co --track origin/branch     # 跟踪某个远程分支创建相应的本地分支")]),t._v(" "),n("li",[t._v("git co -b <local_branch> origin/<remote_branch>  # 基于远程分支创建本地分支，功能同上")]),t._v(" "),n("li",[t._v("git push                         # push所有分支")]),t._v(" "),n("li",[t._v("git push origin master           # 将本地主分支推到远程主分支")]),t._v(" "),n("li",[t._v("git push -u origin master        # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库)")]),t._v(" "),n("li",[t._v("git push origin <local_branch>   # 创建远程分支， origin是远程仓库名")]),t._v(" "),n("li",[t._v("git push origin <local_branch>:<remote_branch>  # 创建远程分支")]),t._v(" "),n("li",[t._v("git push origin :<remote_branch>  #先删除本地分支(git br -d )，然后再push删除远程分支")])]),t._v(" "),n("h3",{attrs:{id:"git-提交"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#git-提交"}},[t._v("#")]),t._v(" git 提交")]),t._v(" "),n("p",[t._v("####用commitlint规范团队的git提交信息\n在一个团队中，每个人的git的commit信息都不一样，五花八门，没有一个机制很难保证规范化，如何才能规范化呢？可能你想到的是git的hook机制，去写shell脚本去实现。这当然可以，其实JavaScript有一个很好的工具可以实现这个模板，它就是commitlint。\n接下来将会讲解如何一步步的使用commitlint。\n一般情况下，commitlint会用在git的hook回调中，最简单的就是和 husky一起使用。\n前提条件是工程是通过git管理的，如果没有先自己创建一个demo工程，用git初始化一下。\n比如创建一个commitlint-test工程：")]),t._v(" "),n("p",[t._v("mkdir commitlint-test cd commitlint-test git init\nnpm 工程初始化")]),t._v(" "),n("p",[t._v("npm init\n安装commitlint")]),t._v(" "),n("h3",{attrs:{id:"安装依赖"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#安装依赖"}},[t._v("#")]),t._v(" 安装依赖")]),t._v(" "),n("p",[t._v("npm install --save-dev @commitlint/{cli,config-conventional}\n在工程更目录添加配置文件commitlint.config.js")]),t._v(" "),n("p",[t._v("echo \"module.exports = {extends: ['@commitlint/config-conventional']};\" > commitlint.config.js\ncommitlint.config.js文件内容如下：")]),t._v(" "),n("p",[t._v("module.exports = {     extends: ['@commitlint/config-conventional'], };\nextends字段表示扩展子@commitlint/config-conventional的配置。一般扩展这个就足够了，这是利用的commitlint的配置宽展机制，可以继承其他人的配置。")]),t._v(" "),n("h3",{attrs:{id:"安装husky"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#安装husky"}},[t._v("#")]),t._v(" 安装husky")]),t._v(" "),n("p",[t._v('husky是一个git hook的管理工具，实现了大部分的git hook，有兴趣的可以自行google。\nnpm install --save-dev husky\n在package.json中配置husky. hooks\n// package.json {   "husky": {     "hooks": {       "commit-msg": "commitlint -E HUSKY_GIT_PARAMS"     }     } }\n通过HUSKY_GIT_PARAMS传递参数，-E|--env用于指向相关的编辑文件。')]),t._v(" "),n("h3",{attrs:{id:"测试"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#测试"}},[t._v("#")]),t._v(" 测试")]),t._v(" "),n("p",[t._v('如果不符合规则，讲无法使用git进行commit，比如下面的，如果想知道有什么规则，可以继续往下看。\ngit commit -m "foo: this will fail" husky > npm run -s commitmsg ⧗   input: foo: this will fail ✖   type must be one of [build, chore, ci, docs, feat, fix, perf, refactor, revert, style, test] [type-enum] ✖   found 1 problems, 0 warnings husky > commit-msg hook failed (add --no-verify to bypass) git commit -m "chore: lint on commitmsg" husky > npm run -s commitmsg ⧗   input: chore: lint on commitmsg ✔   found 0 problems, 0 warnings')]),t._v(" "),n("h3",{attrs:{id:"规则"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#规则"}},[t._v("#")]),t._v(" 规则")]),t._v(" "),n("p",[t._v("git commit的消息这样组成：\n其中header是必须有的，body，footer可选。")]),t._v(" "),n("p",[t._v("header  --空一行 body --空一行 footer\nheader的规则\nCommit message格式，注意冒号后面有空格\n"),n("type",[t._v(": "),n("subject",[t._v("\ntype\n用于说明 commit 的类别，只允许使用下面7个标识，也可以自己在配置文件中更改或者扩展。\n标准类型如下：\nfeat：新功能（feature）\nfix：修补bug\ndocs：文档（documentation）\nstyle： 格式方面的优化\nrefactor：重构\ntest：测试\nchore：构建过程或辅助工具的变动\nsubject\nsubject是 commit 目的的简短描述，不能超过50个字符，且结尾不加英文句号。\n如果type为feat和fix，则该 commit 将肯定出现在 Change log 之中。\n参考：\nhttps://conventional-changelog.github.io/commitlint/#/\nhttps://conventional-changelog.github.io/commitlint/#/reference-rules")])],1)],1),t._v(" "),n("p",[t._v("链接：https://www.jianshu.com/p/8efa36c5dfd4")])])}),[],!1,null,null,null);i.default=e.exports}}]);