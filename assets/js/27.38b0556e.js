(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{384:function(e,v,t){"use strict";t.r(v);var a=t(44),r=Object(a.a)({},(function(){var e=this,v=e.$createElement,t=e._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h3",{attrs:{id:"vue3-0-六大亮点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue3-0-六大亮点"}},[e._v("#")]),e._v(" vue3.0 六大亮点")]),e._v(" "),t("ol",[t("li",[e._v("performance 性能比vue2.x 快1-2倍")]),e._v(" "),t("li",[e._v("Tree shaking support：按需编辑，体积更小")]),e._v(" "),t("li",[e._v("组合类API（类似React Hooks）")]),e._v(" "),t("li",[e._v("支持TS")]),e._v(" "),t("li",[e._v("暴露自定义渲染API")]),e._v(" "),t("li",[e._v("Fragement，Telport，Supspense：更先进的组件")])]),e._v(" "),t("h3",{attrs:{id:"vue3-0变快的原因"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue3-0变快的原因"}},[e._v("#")]),e._v(" Vue3.0变快的原因")]),e._v(" "),t("ol",[t("li",[e._v("vue2中的虚拟dom是进行全量的对比，vue3新增了静态标记(PatchFlag)，在创建虚拟Dom的时候会根据Dom中的内容是否发生变化，添加静态标记，再进行对比的时候只对比有标记的dom")]),e._v(" "),t("li",[e._v("hoistStatic 静态提升\n"),t("ul",[t("li",[e._v("vue2中无论元素是否参与更新，每次都会重新创建，然后再进行渲染")]),e._v(" "),t("li",[e._v("vue3中对于部件与更新的元素，会做静态提升，知会被创建一次，再渲染时直接复用即可")])])]),e._v(" "),t("li",[e._v("cacheHandlers事件监听器缓存\n"),t("ul",[t("li",[e._v("默认情况下onClick会被视为动态绑定，所以每次都会追踪他的而变化，但因为是同一个函数，所以没有追踪变化，直接缓存起来复用即可")])])]),e._v(" "),t("li",[e._v("ssr渲染")])]),e._v(" "),t("h3",{attrs:{id:"vue3-0-项目创建"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue3-0-项目创建"}},[e._v("#")]),e._v(" Vue3.0 项目创建")]),e._v(" "),t("ol",[t("li",[e._v("vite方式\n"),t("ul",[t("li",[e._v("安装vite "),t("code",[e._v("npm install -g create-vite-app")])]),e._v(" "),t("li",[e._v("创建项目 "),t("code",[e._v("create-vite-app projectName")])]),e._v(" "),t("li",[e._v("安装依赖运行 "),t("code",[e._v("cd projectName;npm install;npm run dev")])])])])]),e._v(" "),t("h3",{attrs:{id:"composition-api"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#composition-api"}},[e._v("#")]),e._v(" Composition API")]),e._v(" "),t("ol",[t("li",[t("p",[e._v("Set up注意点")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("执行时间：在breforeCreate和Created中间，所以在setup函数中无法使用data和methods")])]),e._v(" "),t("li",[t("p",[e._v("setup函数只能是同步的，不能是异步的，如果使用异步，可以用async await转换")])]),e._v(" "),t("li",[t("p",[e._v("使用 "),t("code",[e._v("setup")]),e._v(" 函数时，它将接受两个参数：")]),e._v(" "),t("ol",[t("li",[t("p",[t("code",[e._v("props")]),e._v("："),t("code",[e._v("setup")]),e._v(" 函数中的 "),t("code",[e._v("props")]),e._v(" 是响应式的，当传入新的 prop 时，它将被更新。但是，因为 "),t("code",[e._v("props")]),e._v(" 是响应式的，你"),t("strong",[e._v("不能使用 ES6 解构")]),e._v("，因为它会消除 prop 的响应性。如果需要解构 prop，可以通过使用 "),t("code",[e._v("setup")]),e._v(" 函数中的 "),t("a",{attrs:{href:"https://v3.cn.vuejs.org/guide/reactivity-fundamentals.html#%E5%93%8D%E5%BA%94%E5%BC%8F%E7%8A%B6%E6%80%81%E8%A7%A3%E6%9E%84",target:"_blank",rel:"noopener noreferrer"}},[t("code",[e._v("toRefs")]),t("OutboundLink")],1),e._v(" 来完成此操")]),e._v(" "),t("div",{staticClass:"language-vue extra-class"},[t("pre",{pre:!0,attrs:{class:"language-vue"}},[t("code",[e._v("import { toRefs } from 'vue'\n\nsetup(props) {\n\tconst { title } = toRefs(props)\n\n\tconsole.log(title.value)\n}\n")])])])]),e._v(" "),t("li",[t("p",[t("code",[e._v("context")])])])])])])]),e._v(" "),t("li",[t("p",[e._v("reactive注意点")]),e._v(" "),t("ul",[t("li",[e._v("reactive参数必须是对象(json/arr)")]),e._v(" "),t("li",[e._v("如果给reactive传递了其他对象，默认情况下修改对象是不会自动更新的，如果想更新，可以通过重新赋值的方式")])])]),e._v(" "),t("li",[t("p",[e._v("ref 注意点")]),e._v(" "),t("ul",[t("li",[e._v("ref本质其实还是reactive，当我们给ref函数传递一个值后，ref函数底层会自动将ref转换成reactive\tref(18)  -----\x3e reactive({value:18})")]),e._v(" "),t("li",[e._v("如果是通过ref创建的数据，在template中使用的时候不用通过 .value 来获取，vue会自动添加 .value")])])])]),e._v(" "),t("h3",{attrs:{id:"ref-和-reactive的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ref-和-reactive的区别"}},[e._v("#")]),e._v(" ref 和 reactive的区别")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("vue如何决定是否需要自动添加 .value的")]),e._v(" "),t("ul",[t("li",[e._v("vue在解析数据之前，会自动判断数据是否是ref类型，如果是就自动添加 .value属性，不是就不添加")])])]),e._v(" "),t("li",[t("p",[e._v("vue是如何判断当前的数据是否是ref类型的")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("通过当前数据的 "),t("code",[e._v("__v_ref")]),e._v("来判断的")])]),e._v(" "),t("li",[t("p",[e._v("如果有这个私有的属性，并且取值为true，那么就代表是ref类型的数据")])])])])]),e._v(" "),t("h3",{attrs:{id:"ref-和-reactive都是递归监听-非递归监听用-shallowref和shallowreactive"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ref-和-reactive都是递归监听-非递归监听用-shallowref和shallowreactive"}},[e._v("#")]),e._v(" ref 和 reactive都是递归监听，非递归监听用 shallowRef和shallowReactive")]),e._v(" "),t("ul",[t("li",[e._v("注意：如果是通过shallowRef创建数据，那么vue监听的是.value 的变化，并不是第一层的变化")])])])}),[],!1,null,null,null);v.default=r.exports}}]);